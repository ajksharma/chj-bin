#!/usr/bin/perl -w

# Mon Dec  7 23:55:11 EST 2009
(my $email='christian-novo%jaeger,mine,nu')=~ tr/%,/@./;

use strict;

our $metadatadir=".METADATA-v2";
our $metadataignorepath= "$metadatadir.ignore";

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname save|restore

  save: create a directory '$metadatadir' which contains metadata
  information for all files in the current repository except for the
  '$metadatadir' dir itself and, if present, the files listed in
  '$metadataignorepath' (it does *not* git-add or commit it
  automatically currently).

  restore: read '$metadatadir', and restore the contained metadata to
  all files, [except if they have a newer mtime than stored in the
  metadatafile?]

  NOTE: saves/expects on the current directory and subdirs only and
  expects '$metadatadir' in the current directory. So if you want to
  track metadata of the whole repository, cd to the root of the
  working dir first.

  Also, only the files in the current HEAD are tracked ('of course').

  Options:
   --no-mtime / --no-times
       don't restore mtime, only user/group/permissions

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
our $opt_no_time;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "no-times"=> \$opt_no_time,
	   "no-mtime"=> \$opt_no_time,
	   ) or exit 1;
usage unless @ARGV==1;# optinally take list of files to save[well,update?] or restore?
our ($command)= @ARGV;

use Chj::xperlfunc ':all';

##ENDLESS lib stuff:
use Chj::xopen 'xopen_read', 'xopen_write';
sub xContent ( $ ) {
    my ($path)= @_;
    my $f= xopen_read $path;
    my $cntrf= $f->xcontentref;
    $f->xclose;
    $$cntrf
}
#use Chj::xtmpfile;
use POSIX 'ENOENT';
sub xPutfile ( $ $ ) { # the above should then be called xGetfile ?
    my ($path,$str)=@_;
    #my $f= xtmpfile $path;
    #or, really just write directly, here, since in a tmpdir anyway already.'man', heh.
    my $f= do {
	my $f= eval {
	    xopen_write $path;
	};
	if (ref $@ or $@) {
	    my $e=$@;
	    my $errno=$!+0;
	    if ($errno == ENOENT) {
		my $lp; $lp= sub {
		    my ($d)= @_;
		    if ($d eq "." or $d eq "/") {
			# end
		    } else {
			if (-e $d) {
			    # end
			} else {
			    &$lp (dirname $d);
			    mkdir $d;
			}
		    }
		};
		&$lp (dirname $path);
		undef $lp;
		xopen_write $path;
	    } else {
		die $e
	    }
	} else {
	    $f
	}
    };
    $f->xprint ($str);
    $f->xclose;
    # thatsit
}
##/lib


{
    package CHJ::Metadata;
    our @statfields;
    BEGIN {
	@statfields=
	  (
	   #'atime', no good, because some filesystems are not mounted noatime
	   'mtime',
	   # inode: nope, since not stable across filesystems
	   'permissions', #incl setuid and such, right?.
	   'type', #not settable of course. but checkable, ok?. like symlink vs file.
	   'caching_username', #not uid, right?
	   #'uid', #keep anyway? no would give bad diff
	   'caching_groupname',
	  );
    }
    use Class::Array -fields=>
      -publica=>
	(
	 'path',
	 @statfields,
	);
    sub new_from_stat {
	my $cl=shift;
	my ($path,$stat)=@_;
	my $s=$cl->SUPER::new;
	$$s[Path]=$path;
	for my $field (@statfields) {
	    my $setmethod="set_$field";
	    $s->$setmethod($stat->$field);
	}
	$s
    }
    use Chj::xperlfunc 'xlstat','xutime','xchmod','xchown','Xlstat';
    sub maybe_new_from_path {
	my $cl=shift;
	my ($path)=@_;
	if (my $s= Xlstat($path)) {
	    $cl->new_from_stat($path, $s);
	} else {
	    undef
	}
    }
    use Chj::schemestring 'schemestring_oneline','parse_schemestring';
    sub stringify {
	my $s=shift;
	join("\t", #to make parsing easy
	     map {
		 scalar schemestring_oneline(scalar $s->$_)
	     }
	     (
	      @statfields,
	     ))
    }
    sub new_from_path_string { #parse
	my $cl=shift;
	my ($path,$str)=@_;
	my $s=$cl->SUPER::new;
	my @v=
	  (
	   map {
	       scalar parse_schemestring $_
	   }
	   split /\t/, $str
	  );
	@v == 5
	  or die "new_from_string: invalid number of fields in '$str'";
	# pairing how?...
	$$s[Path]= $path;
	for (my $i=0; $i < @statfields; $i++) {
	    my $field= $statfields[$i];
	    my $setmethod="set_$field";
	    $s->$setmethod($v[$i]);
	}
	$s
    }
    # equal method needed?
    sub restore {
	my $s=shift;
	my ($stat)=@_;#since I already have it at hands..
	if ($stat->type eq $s->type) {
	    if ($stat->mtime != $s->mtime
		and not $opt_no_time) {
		if ($stat->is_link) {
		    warn "note: don't know how to set mtime of symlink '".$s->path."'\n";
		} else {
		    # (keep old atime)
		    xutime $stat->atime,$s->mtime, $$s[Path];
		}
	    }
	    if (($stat->uid != $s->xuid)
		or
		($stat->gid != $s->xgid)
		or
		($stat->permissions != $s->permissions)) {
		# make it safe: first disable all access, then set owner, then set perms.
		xchmod 0, $$s[Path];
		xchown $s->xuid, $s->xgid, $s->path;
		xchmod $$s[Permissions], $$s[Path];
	    }
	} else {
	    die "changed type: ".$stat->type." vs ".$s->type;
	}
    }
    sub atime {
	my $s=shift;
	die "not available";
    }
    sub mkx_id {
	my ($idname, $namemethod, $op)=@_;
	sub {
	    my $s=shift;
	    my $name= $s->$namemethod;
	    if (defined (my $res=$op->($name))) {
		$res
	    } else {
		die "x$idname: unknown $namemethod: $name";
	    }
	}
    }
    sub xuid; sub xgid;#prevent warning sigh.
    use Chj::xperlfunc 'caching_getpwnam','caching_getgrnam';
    *xuid= mkx_id ("uid", "caching_username", \&caching_getpwnam);
    *xgid= mkx_id ("gid", "caching_groupname", \&caching_getgrnam);
    end Class::Array;
}


use Chj::xopen 'xopen_read';

our $ignore=
  +{
    $metadatadir=> 1,
    $metadataignorepath=> 1,
   };

if (-f $metadataignorepath) {
    my $in=xopen_read $metadataignorepath;
    while (<$in>) {
	chomp;
	next if (/^\s*\z/ or /^\s*#/);
	my $orig=$_;
	#s/ +\z//;#k?.
	s|//+|/|g;
	s|/\z||; # also ok for '/' entry?
	#XX what to do about "./foo" vs "foo"?
	die "invalid entry '$orig'" unless length;
	$$ignore{$_}++;
    }
    $in->xclose;
}

use Chj::xtmpdir;
use Chj::IO::Command;

sub dir_or_fold {
    my ($pred,$d)=@_;
    if ($d eq "." or $d eq "/") {
	0
    } else {
	(&$pred ($d)) or do {
	    @_=($pred, dirname $d); goto &dir_or_fold;
	}
    }
}


use Chj::Parallel;

use Chj::Git::Functions 'git_ls_files';

our $commands=
  +{
    save=> sub {

	my $outdir= xtmpdir $metadatadir;
	Parallel_for_each
	  (scalar git_ls_files,
	   sub {
	       my ($path)=@_;

	       my $pred= sub {
		   my ($path)=@_;
		   $$ignore{$path}
	       };
	       my $do_ignore= dir_or_fold ($pred,
					   $path);
	       if (not $do_ignore) {
		   if (my $metadata= CHJ::Metadata->maybe_new_from_path ($path)) {
		       xPutfile("$outdir/$path", $metadata->stringify."\n");
		   } else {
		       warn "path '$path' doesn't exist (anymore)\n";
		   }
	       }
	   });

	xxsystem ("rm","-rf","--",$metadatadir);
	$outdir->autoclean(0);
	xrename "$outdir", $metadatadir;
    },
    restore=> sub {
	my $metadatapaths= git_ls_files($metadatadir);

	Parallel_for_each
	  ($metadatapaths,
	   sub {
	       my ($metadatapath)=@_;
	       my $path= substr($metadatapath,length ($metadatadir) + 1);
	       eval {
		   local our $metadata= CHJ::Metadata->new_from_path_string
		     ($path, xContent($metadatapath));
		   my $path= $metadata->path;
		   local our $s= xlstat $path;
		   $metadata->restore($s);
	       };
	       if (ref $@ or $@) {
		   print STDERR "warn: '$path': $@";
	       }
	   });
    }
   };
if (my $c= $$commands{$command}) {
    &$c
} else {
    usage "unknown command '$command'"
}


#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
