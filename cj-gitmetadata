#!/usr/bin/perl -w

# Mon Dec  7 23:55:11 EST 2009
(my $email='christian-novo%jaeger,mine,nu')=~ tr/%,/@./;

use strict;

our $metadatadir=".METADATA-v2";
our $metadataignorepath= "$metadatadir.ignore";

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname save|restore

  save: create a directory '$metadatadir' which contains metadata
  information for all files in the current repository except for the
  '$metadatadir' dir itself and, if present, the files listed in
  '$metadataignorepath' (it does *not* git-add or commit it
  automatically currently).

  restore: read '$metadatadir', and restore the contained metadata to
  all files, [except if they have a newer mtime than stored in the
  metadatafile?]

  NOTE: saves/expects on the current directory and subdirs only and
  expects '$metadatadir' in the current directory. So if you want to
  track metadata of the whole repository, cd to the root of the
  working dir first.

  Also, only the files in the current HEAD are tracked ('of course').

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   ) or exit 1;
usage unless @ARGV==1;# optinally take list of files to save[well,update?] or restore?
our ($command)= @ARGV;

use Chj::xperlfunc ':all';

##ENDLESS lib stuff:
use Chj::xopen 'xopen_read', 'xopen_write';
sub xContent ( $ ) {
    my ($path)= @_;
    my $f= xopen_read $path;
    my $cntrf= $f->xcontentref;
    $f->xclose;
    $$cntrf
}
#use Chj::xtmpfile;
use POSIX 'ENOENT';
sub xPutfile ( $ $ ) { # the above should then be called xGetfile ?
    my ($path,$str)=@_;
    #my $f= xtmpfile $path;
    #or, really just write directly, here, since in a tmpdir anyway already.'man', heh.
    my $f= do {
	my $f= eval {
	    xopen_write $path;
	};
	if (ref $@ or $@) {
	    my $e=$@;
	    my $errno=$!+0;
	    if ($errno == ENOENT) {
		# have to create parent directories.
		#hm. wieder mal wo linked list toll waer.gell?.rg.
		#wl still auf "" name checken needed tho. 2 enden.
		my $lp; $lp= sub {
		    my ($d)= @_;
		    if ($d eq "." or $d eq "/") {
			# end
		    } else {
			if (-e $d) {
			    # end
			} else {
			    &$lp (dirname $d);
			    mkdir $d;
			}
		    }
		};
		&$lp (dirname $path);
		undef $lp;
		xopen_write $path;
	    } else {
		die $e
	    }
	} else {
	    $f
	}
    };
    $f->xprint ($str);
    $f->xclose;
    # thatsit
}
##/lib


{
    package CHJ::Metadata;
    our @statfields;
    BEGIN {
	@statfields=
	  (
	   #'atime', can't use it, because some filesystems are not mounted noatime. And maybe other problems. I don't want to have fussy data in the reposi.
	   'mtime',
	   # inode: nope, since not 'portable' (can't be 'ported' to another sys)
	   'permissions', #inkl setuid and such, right?.
	   'type', #not settable of course. but checkable, ok?. like symlink vs file.
	   'caching_username', #not uid, right?
	   #'uid', #keep anyway? well but no would give bad diff
	   'caching_groupname',
	  );
    }
    use Class::Array -fields=>
      -publica=>
	(
	 'path',
	 @statfields,
	);
    sub new_from_stat {
	my $cl=shift;
	my ($path,$stat)=@_;
	my $s=$cl->SUPER::new;
	$$s[Path]=$path;
	for my $field (@statfields) {
	    my $setmethod="set_$field";
	    $s->$setmethod($stat->$field); #dankseiundwl irg. #h wl wenn op symbols dann auch geh. [heh und jo hash lookup dann heheheh]
	}
	$s
    }
    use Chj::xperlfunc 'xlstat','xutime','xchmod','xchown','Xlstat';
    sub maybe_new_from_path {
	my $cl=shift;
	my ($path)=@_;
	if (my $s= Xlstat($path)) {
	    $cl->new_from_stat($path, $s);
	} else {
	    undef
	}
    }
    use Chj::schemestring 'schemestring_oneline','parse_schemestring';
    sub stringify {
	my $s=shift;
	join("\t", #to make parsing easy harharhar
	     map {
		 scalar schemestring_oneline(scalar $s->$_)
	     }
	     (
	      @statfields,
	     ))
    }
    sub new_from_path_string { #parse
	my $cl=shift;
	my ($path,$str)=@_;
	my $s=$cl->SUPER::new;
	my @v=
	  (
	   map {
	       scalar parse_schemestring $_
	   }
	   split /\t/, $str
	  );
	@v == 5
	  or die "new_from_string: invalid number of fields in '$str'";
	# pairing how?...
	$$s[Path]= $path;
	for (my $i=0; $i < @statfields; $i++) {
	    my $field= $statfields[$i];
	    my $setmethod="set_$field";
	    $s->$setmethod($v[$i]);
	}
	$s
    }
    # equal method needed?
    sub restore {
	my $s=shift;
	my ($stat)=@_;#since I already have it at hands..
	# merke dass ich eben gar nid, einfach, @statfields lesen kan, fall für macros or. spec massige liste. code undso. "or?".[[howdoyoudothatfnctsl?.x]]
	# und zwar nur weil keine methoden da sind  erneut. !.  setten von dingern  solltejustso. wsch haha  wl  .  kopy von fields. altes business  matching so  quasi  wie  closures fabrizieren von ausserem kontext  "???".
	# aber es ist schlimmer, nicht nur missing methods sondern batching ebenfalls.
	# also handarbeit.
	if ($stat->type eq $s->type) { ##aber warum mach ich mtime check vorher zersch? und nid beideshierorso.?. wl nj.hier quasi assert dass es sich umsrichtigehandelt? . [weil link utime nid accessible]
	    if ($stat->mtime != $s->mtime) {
		# (keep old atime)
		xutime $stat->atime,$s->mtime, $$s[Path];
	    }
	    if (($stat->uid != $s->xuid)
		or
		($stat->gid != $s->xgid)
		or
		($stat->permissions != $s->permissions)) {
		# make it safe: first disable all access, then set owner, then set perms.
		xchmod 0, $$s[Path];
		xchown $s->xuid, $s->xgid, $s->path;
		xchmod $$s[Permissions], $$s[Path];
	    }
	} else {
	    die "changed type: ".$stat->type." vs ".$s->type; ## why do I have to re write this. assign to a @v and then?.
	}
    }
    sub atime {
	my $s=shift;
	die "not available";
    }
    sub mkx_id {
	my ($idname, $namemethod, $op)=@_;
	sub {
	    my $s=shift;
	    my $name= $s->$namemethod;
	    if (defined (my $res=$op->($name))) {
		$res
	    } else {
		die "x$idname: unknown $namemethod: $name";
	    }
	}
    }
    sub xuid; sub xgid;#prevent warning sigh.
    use Chj::xperlfunc 'caching_getpwnam','caching_getgrnam';
    *xuid= mkx_id ("uid", "caching_username", \&caching_getpwnam);
    *xgid= mkx_id ("gid", "caching_groupname", \&caching_getgrnam);
    end Class::Array;
}


use Chj::xopen 'xopen_read';

our $ignore=
  +{
    $metadatadir=> 1,
    $metadataignorepath=> 1,
   };

if (-f $metadataignorepath) {
    my $in=xopen_read $metadataignorepath;
    while (<$in>) {
	chomp;
	next if (/^\s*\z/ or /^\s*#/);
	my $orig=$_;
	#s/ +\z//;#k?.
	s|//+|/|g;
	s|/\z||; # also ok for '/' entry?
	#XX what to do about "./foo" vs "foo"?
	die "invalid entry '$orig'" unless length;
	$$ignore{$_}++;
    }
    $in->xclose;
}

use Chj::xtmpdir;
use Chj::IO::Command;
use Chj::IO::DirDeep;

sub dir_or_fold {
    my ($pred,$d)=@_;
    if ($d eq "." or $d eq "/") {
	0
    } else {
	(&$pred ($d)) or do {
	    @_=($pred, dirname $d); goto &dir_or_fold;
	}
    }
}

our $commands=
  +{
    # n sub namensraumnaturlich. derdritte undnamensraum.
    save=> sub {
	my $c= Chj::IO::Command->new_sender ("git","ls-files","-z");
	local $/="\0";
	my $outdir= xtmpdir $metadatadir;
	while (<$c>) {
	    chop;
	    my $path=$_;

	    my $pred= sub {
		my ($path)=@_;
		$$ignore{$path}
	    };
	    my $do_ignore= dir_or_fold ($pred,
					$path);
	    if (not $do_ignore) {
		if (my $metadata= CHJ::Metadata->maybe_new_from_path ($path)) {
		    xPutfile("$outdir/$path", $metadata->stringify."\n");
		} else {
		    warn "path '$path' doesn't exist (anymore)\n";
		}
	    }
	}
	$c->xxfinish;

	# XX really should have a xputback method for tmpdirs as
	# well!! Perms not kept, here. Ah at least it's got private perms.
	# ((Also, could use an abstraction, with the implementation
	# overwriting old files in place and removing files not used
	# anymore; would be cheaper than both rm -rf and trash, I
	# guess))
	xxsystem ("trash",$metadatadir);
	$outdir->autoclean(0);
	xrename "$outdir", $metadatadir;

	# add and commit it?
    },
    restore=> sub {
	my $in= Chj::IO::DirDeep->new( $metadatadir);
	while (my ($metadatapath,$stat)= $in->xnread_deep_files) {
	    my $path= substr($metadatapath,length ($metadatadir) + 1);
	    eval {
		local our $metadata= CHJ::Metadata->new_from_path_string
		  ($path, xContent($metadatapath));
		my $path= $metadata->path;
		local our $s= xlstat $path;
		$metadata->restore($s);
	    };
	    if (ref $@ or $@) {
		print STDERR "warn: one record failed: $@";
	    }
	}
    }
   };
if (my $c= $$commands{$command}) {
    &$c
} else {
    usage "unknown command '$command'"
}


#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
