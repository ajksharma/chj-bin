#!/usr/bin/perl -w

# Mon Jul 21 13:09:34 CEST 2008
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);

our $commitmsg_body= sub {
    my ($maybe_commitmsg, $versionnumber)=@_;
    # careful: $versionnumber can also be a string ("current")
    my $body= "(version: $versionnumber; imported by $myname)";
    if ($maybe_commitmsg) {
	chompspace($maybe_commitmsg)."\n\n".$body
    } else {
	$body
    }
};

our $sort_by= "mtime"; # a CHJ_CJGITIMPORT::Entry method

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname files

  Give all kept files of one file; it will commit them in order and
  with AUTHOR_TIME set to their mtime.

  Only works for one file at a time (maybe create a new empty branch
  using cj-git-fast-switch-branch and merge afterwards). See
  cj-git-import-keephistory for another more complicated approach.

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   ) or exit 1;
usage unless @ARGV;


##*modified* COPY from cj-git-import-keephistory
sub file_to_source_versionnumber_maybemsg ( $ ) {
    my ($fullfile)=@_;
    if ($fullfile=~ m/(.+)\.([1-9][0-9]*)(?:_(.*))?\z/s) {
	($1,$2,$3)
    } else {
	()
    }
}

##/COPY

use Chj::chompspace;
use Chj::xperlfunc ':all';

{
    package CHJ_CJGITIMPORT::Entry;
    use Class::Array -fields=>
      -publica=>
	(
	 'path',
	 'stat',
	 'basename',
	 'version', # can be "current"
	 'maybe_message'
	);
    sub mtime {#und schon hab ich n delegate
	my $s=shift;
	$$s[Stat]->mtime
    }
    end Class::Array;
}

# slurp in data
our $entries=
  do {
      my $seen_unversioned_item;
      [
       # filepath, basename, maybe_versionnumber, maybe_msg, statobject
       # basename should be identical for all files; check for this afterwards.
       map {
	   my $stat= xlstat ($_);
	   if (my ($basename,$vers,$msg)=
	       file_to_source_versionnumber_maybemsg ($_)) {
	       bless [
		$_,
		$stat,
		$basename,
		$vers,
		$msg,
	       ], "CHJ_CJGITIMPORT::Entry"
	   } else {
	       if ($seen_unversioned_item) {
		   die "more than one item without a versionnumber: "
		     ."'$seen_unversioned_item' and '$_'";
	       } else {
		   $seen_unversioned_item=$_;
		   bless [
		    $_,
		    $stat,
		    $_,
		    "current", #undef,
		    undef #"current", ##
		   ], "CHJ_CJGITIMPORT::Entry"
	       }
	   }
       } @ARGV
      ]
  };

# check that everything is of the same file:
{
    my $first_basename= $$entries[0]->basename;
    for (@$entries[1..$#$entries]) {
	my $current_basename= $_->basename;
	$current_basename eq $first_basename
	  or die "not all files are of the same basename: "
	    ."'$first_basename' vs. '$current_basename'";
    }
}

#for (sort { $a->$sort_by )



#use Chj::ruse;
use Chj::Backtrace; use Chj::repl; repl;
