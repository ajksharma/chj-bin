#!/usr/bin/perl -w

# Wed Aug 19 19:00:55 EDT 2009
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

our $sleeptime= 0.1;#
our $postsleeptime=0.1;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname path(s)

  Watch the given path(s) and exit with success if one of them changed
  (looking at stat info only). Exit with error code if there was an
  error.

  Do this by polling with sleeptime $sleeptime seconds.

  Options:

    --post x   sleep x instead of $postsleeptime seconds after noticing
               a change (floating point value)

  (This might be a stepping stone in the simplification of my many
   old scripts like watchandprocess, observe_contentchange, ..)

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "post=s"=> \$postsleeptime,
	   ) or exit 1;
usage unless @ARGV;

use Chj::xperlfunc 'xlstat'; #or xstat ?
*x_stat= *xlstat;
use Time::HiRes 'sleep';

sub getstats {
    [
     map {
	 scalar x_stat ($_)
     } @ARGV
    ]
}

my $nfiles= @ARGV;
my $stats= getstats;

#there was something to ask for change right.  yep equal and equal_content

OUTER: { #GR
    while (1) {
	sleep $sleeptime;
	my $newstats= getstats;
	for (my $i=0; $i<$nfiles; $i++) {
	    if ($$stats[$i]->equal($$newstats[$i])) {
		# ok keep on going
	    } else {
		last OUTER;
	    }
	}
    }
}

sleep $postsleeptime
  if $postsleeptime;

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
