#!/usr/bin/perl -w

# Sam Feb  9 12:32:53 CET 2008
(my $email='pflanze%gmx,ch')=~ tr/%,/@./;

use strict;
our @known_types= qw(commit tree blob tag);

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname

  List all tags in the current git repository which are signed, sorted
  by their creation date.

  Options:
  -v|--invert show tags which are *not* signed
  --all       show all tags, also non-signed ones
  --non-annotated  only show non-annotated tags (implies --all)
  --verbose   show some warning(s)
  --type x    show tags pointing to objects of type x only
              (the usual ones: @known_types)

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

my $known_types= +{ map { $_=> 1} @known_types };

use Getopt::Long;
my $options={};
our $opt_type;
GetOptions($options,
	   "v|invert",
	   "all",
	   "non-annotated",
	   "help"=> sub{usage},
	   "type=s"=> sub {
	       my ($k,$t)=@_;
	       $$known_types{$t}
		 or die "$myname: unknown type '$t'; we only know of: @known_types\n";
	       $opt_type= $t;
	   },
	   "verbose",
	   #"debug",
	  )
  or exit 1;
usage if @ARGV;
our $verbose= $$options{verbose};

{
    package Chj_App::ParsedTag;
    use Class::Array -fields=> -publica=>
      (qw(name maybe_contentrf maybe_unixtime maybe_tagger is_signed),
       # and for caching:
       '_maybe_unixtime', # promise
       '_sha1', # cache
       '_Dereferenced_type',
      );
    use Chj::FP::Memoize ();# 'memoize_thunk';
    our $sha1_re= qr/\b[0-9a-f]{40}\b/;
    sub new {
	my $cl=shift;
	my $s=bless [@_],$cl;
	$$s[_Maybe_unixtime]=
	  Chj::FP::Memoize::memoize_thunk
	      (sub {
		   if (defined (my $val= $$s[Maybe_unixtime])) {
		       $val
		   } elsif (1) {
		       # the tag either isn't an annotated tag, or is
		       # of the old type which didn't carry a tagger
		       # line. Dereference it to the commit object and
		       # use the commit object's commit time instead.
		       # (Well, we expect it to be a commit, which
		       # isn't necessarily true)
		       my $sha1= $s->dereferenced_sha1;
		       if (my $rf= main::maybe_cat_file ("commit",$sha1)) {
			   $$rf=~ /^committer .* (\d{8,}) +[+-]\d{4} *$/m
			     # is . really not matching \n here? hm seems so, only /s does make . match \n according to man perlre
			     or die "missing committer field in commit '$sha1': '$$rf'";
			   $1
		       } else {
			   0 ## undef
		       }
		   } else {
		       0 ## undef
		   }
	       });
	$s
    }
    sub is_annotated {
	my $s=shift;
	$$s[Maybe_contentrf] and 1
    }
    #*dereferenced_sha1= Mk_dereference ()
    #  sub Mk_dereference ( $ ) {
    #nah it's not that simple. could short-cut the unannotated case but not the others.
    sub dereferenced_sha1 {
	my $s=shift;
	if (defined (my $r= $$s[_Sha1])) {
	    $r
	} else {
	    my $r= do {
		if (my $rf= $$s[Maybe_contentrf]) {
		    # annotated.
		    $$rf=~ /^object ($sha1_re)/m
		      or die "tag object '$$s[Name]' does not carry an object line";
		    $1
		} else {
		    # unannotated tag. use rev-parse
		    my $rf= main::xgit_stdout_ref ("rev-parse", $$s[Name]);
		    $$rf=~ /^($sha1_re)\s*\z/s
		      or die "rev-parse did not return a sha1 for '$$s[Name]': '$$rf'";
		    $1
		}
	    };
	    $$s[_Sha1]= $r;
	    $r
	}
    }
    sub dereferenced_type {
	my $s=shift;
	$$s[_Dereferenced_type] ||= do {
	    my $rf= main::xgit_stdout_ref ("cat-file",
					   "-t",
					   $s->dereferenced_sha1);
	    $$rf=~ /^(\w+)\s*\z/s or die "invalid output '$$rf'";
	    $1
	}
    }
    sub maybe_unixtime {
	my $s=shift;
	&{$$s[_Maybe_unixtime]}
    }
    end Class::Array;
}

use Chj::IO::Command;


sub xgit_stdout_ref {
    my $t= Chj::IO::Command->new_sender ("git",@_);
    my $rf= $t->xcontentref;
    $t->xxfinish;
    $rf
}

sub parse_tag {
    my ($name,$maybe_strrf)=@_;
    if (my $strrf= $maybe_strrf) {
	my $is_signed= $$strrf=~ /^-----BEGIN PGP SIGNATURE-----$/m;
	my ($maybe_unixtime,$maybe_tagger)= do {
	    if ($$strrf=~ /^(?:[^\n]+\n)*[Tt]agger ([^\n]*) (\d+) [-+\d]\d+ *\n/s) {
		($2,$1)
	    } else {
		warn "no match for tagger field in tag '$name': '$$strrf'"
		  if $verbose;
		(undef,undef)
	    }
	};
	Chj_App::ParsedTag->new($name,$strrf,$maybe_unixtime,$maybe_tagger,$is_signed);
    } else {
	# un-annotated tag
	Chj_App::ParsedTag->new($name,undef,undef,undef,0);
    }
}

sub maybe_cat_file { # returns content ref, or undef in 'bad file' case (i.e. un-annotated tag), hm, hacky since that only makes sense for cat_tag?
    my ($type,$id)=@_;
    my $t= Chj::IO::Command->new_combinedsender("git","cat-file",$type,$id);
    my $rf= $t->xcontentref;
    my $res= $t->xfinish;
    if ($res==0) {
	$rf
    } else {
	if ($$rf=~ /bad file$/) {
	    undef
	} else {
	    # seems a real error has happened
	    die "git cat-file $type $id exited with code $res and message '$$rf'";
	}
    }
}

sub maybe_cat_tag {
    my ($id)=@_;
    maybe_cat_file ("tag",$id)
}

sub getsignedtagsparsedandsorted {
    my $ls= Chj::IO::Command->new_sender("git","tag","-l");
    my $curried_xor= sub {
	my ($v)=@_;
	$$options{v} ? !$v : $v
    };
    my $res= [
	      sort {
		  ($a->maybe_unixtime <=> $b->maybe_unixtime
		   or
		   $a->name cmp $b->name)
	      }
	      grep {
		  my $t= $opt_type && $_->dereferenced_type;
		  (
		   ($t ? $t eq $opt_type : 1)
		   and
		   ($$options{"non-annotated"} ?
		    not($_->is_annotated)
		    :
		    ($$options{all}
		     ||
		     &$curried_xor($_->is_signed)))
		  )
	      }
	      map { chomp; parse_tag($_, maybe_cat_tag ($_)) }
	      <$ls>
	     ];
    $ls->xxfinish;
    $res
}

for (@{ getsignedtagsparsedandsorted() }) {
    print localtime($_->maybe_unixtime)."\t".$_->name."\t".($_->maybe_tagger||"")."\n";
}
