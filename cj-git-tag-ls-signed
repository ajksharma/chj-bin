#!/usr/bin/perl -w

# Sam Feb  9 12:32:53 CET 2008
(my $email='pflanze%gmx,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname

  List all tags in the current git repository which are signed, sorted
  by their creation date.

  Options:
  -v|--invert show tags which are *not* signed
  -a|--all  show all tags
  --verbose   show some warning(s)

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
my $options={};
GetOptions($options,
	   "v|invert",
	   "a|all",
	   "help"=> sub{usage},
	   "verbose",
	   #"debug",
	  )
  or exit 1;
usage if @ARGV;
our $verbose= $$options{verbose};

{
    package Chj_App::ParsedTag;
    use Class::Array -fields=> -publica=>
      (qw(name maybe_contentrf maybe_unixtime maybe_tagger is_signed));
    sub new {
	my $cl=shift;
	bless [@_],$cl
    }
    end Class::Array;
}

use Chj::IO::Command;

sub parse_tag {
    my ($name,$maybe_strrf)=@_;
    if (my $strrf= $maybe_strrf) {
	my $is_signed= $$strrf=~ /^-----BEGIN PGP SIGNATURE-----$/m;
	my ($maybe_unixtime,$maybe_tagger)= do {
	    if ($$strrf=~ /^(?:[^\n]+\n)*[Tt]agger ([^\n]*) (\d+) [-+\d]\d+ *\n/s) {
		($2,$1)
	    } else {
		warn "no match for tagger field in tag '$name': '$$strrf'"
		  if $verbose;
		(undef,undef)
	    }
	};
	Chj_App::ParsedTag->new($name,$strrf,$maybe_unixtime,$maybe_tagger,$is_signed);
    } else {
	# un-annotated tag
	Chj_App::ParsedTag->new($name,undef,undef,undef,0);
    }
}

sub maybe_cat_file { # returns content ref, or undef in 'bad file' case (i.e. un-annotated tag), hm, hacky since that only makes sense for cat_tag?
    my ($type,$id)=@_;
    my $t= Chj::IO::Command->new_combinedsender("git","cat-file",$type,$id);
    my $rf= $t->xcontentref;
    my $res= $t->xfinish;
    if ($res==0) {
	$rf
    } else {
	if ($$rf=~ /bad file$/) {
	    undef
	} else {
	    # seems a real error has happened
	    die "git cat-file $type $id exited with code $res and message '$$rf'";
	}
    }
}

sub maybe_cat_tag {
    my ($id)=@_;
    maybe_cat_file ("tag",$id)
}

sub getsignedtagsparsedandsorted {
    my $ls= Chj::IO::Command->new_sender("git","tag","-l");
    my $curried_xor= sub {
	my ($v)=@_;
	$$options{v} ? !$v : $v
    };
    my $res= [
	      sort { $a->maybe_unixtime <=> $b->maybe_unixtime }
	      grep { $$options{a} || &$curried_xor($_->is_signed) and $_->maybe_unixtime }
	      map { chomp; parse_tag($_, maybe_cat_tag ($_)) }
	      <$ls>
	     ];
    $ls->xxfinish;
    $res
}

for (@{ getsignedtagsparsedandsorted() }) {
    print localtime($_->maybe_unixtime)."\t".$_->name."\t".$_->maybe_tagger."\n";
}
