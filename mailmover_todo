#!/usr/bin/perl -w

# Sam Nov 29 23:17:06 MET 2003
(my $email='pflanze%gmx,ch')=~ tr/%,/@./;

use strict;
use Chj::xopendir;
use Chj::xopen qw(xopen_read);
use Chj::xperlfunc;

$0=~ /(.*?)([^\/]+)\z/s or die "?"; 
my ($mydir, $myname)=($1,$2); 
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname -d sourcedir | -f sourcefile(s)  targetbase

  (Christian Jaeger <$email>)
";
exit @_ ? 1 : 0;
}

my @args;
my $DEBUG=0;
my $verbose=0;
my ($sourcedir);
my $opt_leaveinbox;
for (my $i=0; $i<=$#ARGV; $i++) {
    local $_=$ARGV[$i];
    if (/^--?h(elp)?$/) {
    	usage
    } elsif ($_ eq '--') {
    	push @args, @ARGV[$i+1..$#ARGV];
    	last;
    } elsif (/^--?d(?:dir(?:=(.*))?)?$/) {
        if (defined $1) {
            $sourcedir=$1
        } else {
            $sourcedir=$ARGV[++$i] or usage "missing argument for '$_' option";
        }
    } elsif (/^--?d(ebug)?$/) {
	$DEBUG=1;
    } elsif (/^--leave-inbox$/) {
	$opt_leaveinbox=1;
    } elsif (/^--?(v+)(?:erbose)?$/) {
	$verbose+=length($1);
    } elsif (/^-./) {
    	usage("Unknown option '$_'\n");
    } else {
    	push @args, $_
    }
}
usage unless @args;

{
    package MailUtil;
    our ($verbose,$raiseerrors);
    sub pick_out_of_anglebrackets {
	my @res= map {
	    /<([^>]*)>/
	} @_;
	wantarray ? @res : @res>1 ?
	  do{my $msg= "multiple angle brackets found but only one expected"; $raiseerrors ? die $msg : $verbose ? warn $msg : return;return}
	    : @res<1 ? do{my $msg="no angle brackets in '$res[0]'"; $raiseerrors ? die $msg : $verbose ? warn $msg : return;return} ## noch in ne typed exception umwandeln?..
	      : $res[0];
    }
    # das ewige error reporting: warn nur wenn man $verbose hat, wie verbose angeben, dasselbe bei die: nur wenn func x heisst oder eben auch $irgendwas. context abfragen: isches das was perl6 von wegen context will? "nur dann warn oder die wenn der context es will". andersch isch exception und catch: der context sagt mittels sowas was dann passiert  wär aber ein context around one single call each time aber noetig allenfalls  oder son operator der es umwandelt in was andres  per operator umwandeln  isch schon no cool.
}

{
    package MailHead;
    use Class::Array -fields=>(
			       # ps warum's Inmail class gibt in elcms: weil es inder db es ja auch so gross will wie es eben ist i.e. ram grösse.  (chunking?)
			       # enum? wie schon machte ich jenes, zahlen versus db.
			       'Errors', #arrayrf
			       'Warnings', #arrayrf
			       'HeadersHash', #hashref, only single headers
			       'HeadersArray', #arrayref, all headers
			      );

    sub new_from_fh {
	my $class=shift;
	my ($fh)=@_; # assume this is blessed to Chj::IO::File? or do it now?
	# assume it is rewinded.!
	my $self= $class->SUPER::new;
	@{$self}[Errors,Warnings]= ([],[]);

	my (%header,@headers,@errors);
	my ($lastheaderkey);
      HEADER:{
	    local $_;
	    while (defined($_=$fh->xreadline)) {
		chomp;# is this safe enough (i.e. does it strip both cr and lf?)
		if (length) {
		    if (/^(\w[\w.-]+): *(.*)/) {
			$lastheaderkey=lc($1);
			push @headers,$_;
			if (exists $header{$lastheaderkey}) {
			    #push @errors,"encountered header '$lastheaderkey' multiple times, now with '$_'";
			    undef $header{$lastheaderkey};
			} else {
			    $header{$lastheaderkey}=[$#headers,$1,$2];
			}
		    } elsif (/^\s+(.*)/) {  #(naja, ist das alles so wirklich korrekt?)
			if ($lastheaderkey) {
			    $headers[-1].="\n\t$1";
			    $header{$lastheaderkey}[2].="\n\t$1" if defined $header{$lastheaderkey};
			    #warn "(DEBUG: multiline header)";
			} else {
			    push @errors, "First header does not start with a key: '$_'";
			}
		    } else {
			push @errors, "Header of unknown format: '$_'";
		    }
		} else {
		    last HEADER;
		}
	    }
	    # ran out of data before finishing headers? Well there is no guarantee that a mail has a body at all (not even the empty line inbetween), so it's not an error.
	}
	@{$self}[HeadersHash,HeadersArray]= (\%header,\@headers);
	$self->[Errors]= \@errors;
	$self
    }

    sub header {
	my $self=shift;
	my ($key)=@_;
	if (my $h=$$self[HeadersHash]{lc($key)}) {
	    $h->[2]
	} else {
	    undef
	}
    }

    # gehört evtl auch nich mehr ins base package:
    sub messageid {
	my $self=shift;
	my $msgid= $self->header("message-id") or return;
	$msgid= pick_out_of_anglebrackets($msgid);
    }

    # gehört nicht mehr ins base package:
    my %known_list_precedences= map {$_=>undef} qw( bulk list );
    sub mailinglist_id {
	my $self=shift;
	my ($value,$id);
      SEARCH:{
	    # prioritize list-post over list-id since it contains the @ char?
	    if ($value= $self->header("List-Post")) {
		if ($value=~ /<([^<>]{3,})>/) { # just in case
		    $id=$1;# hier ist dann bei ssh list noch mailto: dabei
		    last SEARCH;
		} elsif (length $value > 3) {
		    warn "even if ssh mailinglist did put List-Post value into <>, this one did not ('$value')";
		    $id=$value;
		    last SEARCH;
		} else {
		    warn "(almost-)empty List-Post header '$value'";
		}
	    }
	    if ($value= $self->header("List-Id")) {
		if ($value=~ /<([^<>]{3,})>/) {
		    $id=$1;
		    last SEARCH;
		} else {
		    warn "invalid list-id format '$value'";
		}
	    } #els
	    if ($value= $self->header("x-mailing-list")) {
		if ($value=~ /<([^<>]{3,})>/) {
		    $id=$1;
		    last SEARCH;
		} else {
		    warn "invalid x-mailing-list format '$value'";
		}
	    }
	    # Qmail list ist so: Mailing-List: contact qmail-help@list.cr.yp.to; run by ezmlm
	    if ($value= $self->header("Mailing-List")) {
		if ($value=~ /<([^<>]{3,})>/) {
		    warn "even if Qmail (yet another ezmlm based, right??) mailing list didn't use <..> format, this list does ('$value')";
		    $id=$1;
		    last SEARCH;
		} elsif($value=~ /([^\s\@;:,?]+\@[^\s\@;:,?]+[a-z])/) {
		    $id= $1;
		    last SEARCH;
		} else {
		    warn "invalid x-mailing-list format '$value'";
		}
	    }
	    if (my $precedence= $self->header("precedence")) {
		$precedence= lc($precedence);
		$precedence=~ s/^\s+//s;
		$precedence=~ s/\s+\z//s;
		if (exists $known_list_precedences{$precedence}) {
		    if ($value= $self->header("Resent-From")) {
			if ($value=~ /<([^<>]{3,})>/) { # just in case
			    warn "note: even if debian mailinglists do not put resent-from into <>, this mail did it ('$value')";
			    $id=$1;
			    last SEARCH;
			} elsif (length $value > 3) {
			    $id=$value;
			    last SEARCH;
			} else {
			    warn "(almost-)empty Resent-From '$value'";
			}
		    }
		    if ($value= $self->header("Resent-From")) {
			if ($value=~ /<([^<>]{3,})>/) { # just in case
			    warn "note: even if debian mailinglists do not put resent-from into <>, this mail did it ('$value')";
			    $id=$1;
			    last SEARCH;
			} elsif (length $value > 3) {
			    $id=$value;
			    last SEARCH;
			} else {
			    warn "(almost-)empty Resent-From '$value'";
			}
		    }
		    # lugs: (mail alt dings)
		    if ($value= $self->header("sender")
			and $value=~ /^owner-(.*)/si) {
			$id=$1;
			last SEARCH;
		    }
		}
	    }
	    #warn "not a list mail";
	    return;
	}
	#warn "listmail: $id\n";
	$id=~ s/^mailto:\s*//si;
	return $id;
    }

    sub is_spam {
	my $self=shift;
	if (my $status=$self->header("X-Spam-Status")) {
	    if ($status=~ /^\s*yes\b/si) {
		return 1;
	    } else {
		return 0;
	    }
	} else {
	    return undef
	}
    }

}

sub conditional_move_file($ $ ) {
    my ($filepath,$targetbase)=@_;
    my $filename=$filepath; $filename=~ s{^.*/}{}s;
    my $f= xopen_read $filepath;
    my $head= MailHead->new_from_fh($f);

    my $foldername;

    my $is_spam= $head->is_spam;
    if ($is_spam) {
	warn "'$filename' is spam\n" if $DEBUG;
	$foldername="spam";
    } elsif (! defined $is_spam) {
	warn "'$filename' is_spam: not scanned\n" if $verbose;
    }
    if (!$foldername) {
	my $list= $head->mailinglist_id;
	if (defined $list) {
	    warn "'$filename': mailinglist $list\n" if $DEBUG;
	} else {
	    warn "'$filename': not a list mail\n" if $DEBUG;
	}
	#if (!$list and 0) {
	#use Data::Dumper;
	#print "head for $filepath:",Dumper($head);
	#}
	if ($list and not $list=~ /debian-security-announce/i) {
	    $foldername=$list;
	    $foldername=~ s{/}{--}sg; # well, wird nun eh unten nochmals gemacht.
	}
    }

    my $from;my $content;
    # noch gemäss subject einiges filtern:
    if (!$foldername) {
	if (my $subject= $head->header("subject")) {
	    # system mails
	    if ($subject=~ /^([a-zA-Z][\w-]+)\s+\d+.*\d system check\s*\z/) {
		$foldername="systemcheck-$1";
		##ps.punkte dürfen in maildir foldernamen dann nicht vorkommen. weils separatoren sind. quoting möglich? in meiner library dann.
	    } elsif ($subject eq 'DEBUG') {
		$foldername= "DEBUG";
	    } else {
		$from= $head->header("from");
		if ($subject=~ /^\[LifeCMS\]/
		    and ( $from eq 'alias@ethlife.ethz.ch'
			  or $from eq 'newsletter@ethlife.ethz.ch') ) {
		    $foldername= $subject;#gefährlich? jaaaa war es!!! jetzt hab ich unten geflickt.
		} elsif ($subject=~ /^Cron/ and $from=~ /Cron Daemon/) {
		    $foldername= $subject;
		} elsif ($subject=~ /out of office autoreply/i
			 #or
			) {
		    $foldername= "AUTOREPLY";
		} elsif ($subject=~ /^Delivery Status Notification/
			 and $from=~ /^postmaster/) {
		    $foldername= "BOUNCE";
		} elsif (#$subject=~ /failure notice/ and
			 ($from=~ /\bMAILER[_-]DAEMON\@/i
			  or
			  $from=~ /\bpostmaster\@/i
			 )
			 #and $content=~ /ETH Life Newsletter/
			 #and $messageid=~ /\@ethlife.ethz.ch/  # dann kam sie von hier. ; eh1: ist im content. eh2: muss auch lifecms enthalten. aber alte nl tun dies nicht.
			) {
		    $f->xread($content,5000);##das isch teil vom *body*, nicht head!, right?.
		    if ($content=~ /From: ETH Life/) {
			$foldername= "newslettermanuell..$from";
		    } elsif ($content=~ /Message-[Ii]d:[^\n]+lifecms/) {
			$foldername= "lifecms..$from";
		    }
		    # else do not filter it.
		}
		# VIREN!:
		elsif ($subject eq 'New Internet Critical Pack'
		      or $subject=~ /^\!VIRUS:/){
		    $foldername= "VIRUS";
		}
		elsif (my $virusscan= $head->header("X-Virus-Scan-Result")) {
		    if ($virusscan=~ /^Repaired/) {
			$foldername= "VIRUS";
		    }
		}
	    }
	}
    }
    if (!$foldername) {
	if (my $to= $head->header("to")) {
	    if ($to=~ /^(postmaster\@[^\@;:,\s]+[a-z])/) {
		$foldername= $1;
	    }
	}
    }

    # nichts matchende sonstwohin:
    if (!$foldername) {
	my $s= xstat $filepath;
	if ($s->size > 15000) {
	    $foldername="inbox-big";
	} else {
	    $foldername="inbox" unless $opt_leaveinbox;
	}
    } else {
	if ($foldername eq "inbox" or $foldername eq "inbox-big") {
	    die "mail '$filename' somehow managed to get foldername '$foldername'";
	}
    }

    if ($foldername) {
	$foldername=~ s{/}{--}sg;#!wichtig!.. nochmals.
	my $targetfolder= "$targetbase/$foldername";
	if (! -d $targetfolder) {
	    xmkdir $targetfolder;
	}
	my $targetpath= "$targetfolder/$filename";
	$f->xlinkunlink($targetpath);
	warn "moved '$filename' to '$targetpath'\n" if $verbose;

	# nun noch schauen, ob es mir gemeldet werden soll, oder verzeichnet:

	#my $messageid= $head->header("message-id");
	# noch cleanen?
	# Message-Id: <1077177728.3558.22.camel@eva>
	#In-Reply-To: <20031212060110.M27556@computeraddictions.com.au>
	#References: <20031212060110.M27556@computeraddictions.com.au>
	# ja cleanen. eigene methode
      INDEXING: {
	    my $messageid= $head->messageid or do{ warn "'$filename' does not have a message-id\n" if $verbose; last INDEXING};
	    
	

	
    } else {
	warn "'$filename' not moved\n";# if $verbose; ## hey, die bleiben dann auf ewig da liegen!
    }
}


my $targetbase= pop @args;

$|=1;

usage "only one source dir argument allowed" if $sourcedir and @args;

if ($sourcedir) {
    my $d= xopendir $sourcedir;
    while(defined(my$item=$d->xnread)){
	conditional_move_file("$sourcedir/$item",$targetbase);
    }
}
elsif (@args) {
    for my $filepath (@args) {
	conditional_move_file($filepath,$targetbase);
    }
}
else {
    usage "no source dir or files given";
}

MANN
vergessen das fertigzumachen
-rwxrwxr-x    1 root     root        10216  3. Dez 18:38 mailmover.0_ochbevorwurschteln
-rwxrwxr-x    1 root     root        12008 19. Feb 15:39 mailmover
Mit Feb 25 23:34:51 MET 2004
gruss
