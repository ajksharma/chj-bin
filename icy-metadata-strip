#!/usr/bin/perl -w

# Sat Aug  9 22:54:05 CEST 2008
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname file

  writes the file, which is a captured http stream *including the http
  reply headers*, to stdout with the headers and metadata stripped.

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   ) or exit 1;
usage unless @ARGV==1;
our ($file)=@ARGV;

# read how, bytewise? or just normal buffered functions all
# through?. well latter since anyway blah.

use Chj::xopen 'xopen_read';
use Chj::chompspace;

local our $in=xopen_read $file;
local our $headers={};
while (<$in>) {
    s/[\r\n]+\z//s;
    if (/^\z/) {
	last; ##hm are both \r and \n consumed at that point or only one?
    }
    if (/^HTTP\//i) {
	# ignore
    } else {
	my ($key,$val)= split /:/,$_,2
	  or die "non-header?: '$_'";
	#well that wasn't a guarantee yet for 2 fields grr.?. anyway.
	defined $val or die "invalid header: '$_'";
	$$headers{lc(chompspace $key)}= chompspace($val);
    }
}

use Chj::xperlfunc;

# http://www.smackfu.com/stuff/programming/shoutcast.html
sub read_icy_data ( $ ) {
    my ($in)=@_;
    my $len= do {
	my $ch= getc $in; defined $ch or die "read error?: $!";
	16 * ord $ch
    };
    #warn "len=$len";
    my $buf;
    $in->xread($buf,$len);
    $buf
}

local our $metainterval= $$headers{'icy-metaint'}
  or die "no icy-metaint header, thus no icy metadata present, right?";

local our $out= bless *STDOUT{IO},"Chj::IO::File";#usual crack

my $buf;
my $pos_shrunk=0;
while (1) {
    my $len= $in->xread($buf, $metainterval);
    if ($len==0) {
	last;
    } elsif ($len == $metainterval) {
	#$pos_shrunk+= $out->xprint ($buf);  NOPE that's wrong. grr todo fix my lib?
	$out->xprint ($buf);
	$pos_shrunk+=length($buf);
	# now skip until \0 found. or capture if you want
	local our $str= read_icy_data ($in);
	if (length $str) {
	    if ($str=~ /StreamTitle='(.*?)';/i) {
		print STDERR "$pos_shrunk\t$1\n";
	    } else {
		use Chj::Backtrace; use Chj::repl; repl
	    }
	}
    } else {
	warn "nearing end of file? only got $len bytes ".
	  "(after outputting $pos_shrunk bytes)";
	#$pos_shrunk+= $out->xprint ($buf);
	$out->xprint ($buf);
	$pos_shrunk+=length($buf);
	## set flag which makes us terminate if it proceeds?.
	## well or just <> here and expect eof.
    }
}

$out->xclose;
$in->xclose;

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
