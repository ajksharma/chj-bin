#!/usr/bin/perl -w

# Sam Jan 20 19:16:43 MET 2007
(my $email='pflanze%gmx,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname file1 file2

  Do not output lines which occur only in one of the inputs.

  --sorted  assume that inputs are sorted
            (otherwise sort files with csort)

  See also:
     minus

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

my @args;
my $DEBUG=0;
my $opt_sorted;
for (my $i=0; $i<=$#ARGV; $i++) {
    local $_=$ARGV[$i];
    if (/^--?h(elp)?$/) {
    	usage
    } elsif ($_ eq '--') {
    	push @args, @ARGV[$i+1..$#ARGV];
    	last;
    } elsif (/^--?d(ebug)?$/) {
	$DEBUG=1;
    } elsif (/^--?s(orted)?$/) {
	$opt_sorted=1;
#     } elsif (/^--?X(?:XXX(?:=(.*))?)?$/) {
#         if (defined $1) {
#             $XXX=$1
#         } else {
#             $XXX=$ARGV[++$i] or usage "missing argument for '$_' option";
#         }
    } elsif (/^-./) {
    	usage("Unknown option '$_'\n");
    } else {
    	push @args, $_
    }
}
usage unless @args==2;

# Need 'flush' in the IO::Handle namespace:
use IO::Handle;

sub xprint {
    print @_
      or die "printing to stdout: $!";
}

sub join_sorted {
    local our ($A,$B)=@_;
    local our $curcmpline= $A->xreadline;
    local our $curturn= $B;
  WORK: {
	defined $curcmpline
	  or last WORK;
	chomp $curcmpline;
	local our $line= $curturn->xreadline;
	while (defined $line) {
	    chomp $line; # XX spaghetti
	    local our $change= ($line cmp $curcmpline);
	    if (not $change) {
		xprint $line,"\n";
		# begin anew:
		$curcmpline= $A->xreadline;
		last WORK
		  unless defined $curcmpline;
		chomp $curcmpline;# !!!!!!!
		$curturn= $B;
	    } else {
		if ($change<0) {
		    # continue to read lines from $curturn
		} else {
		    # overrun.
		    $curturn= ($curturn eq $A ? $B : $A);
		    $curcmpline= $line;
		}
	    }
	    $line= $curturn->xreadline;
	}
    }
    $A->xfinish;
    $B->xfinish;
    flush STDOUT
      or die "couldn't flush stdout: $!";
}

use Chj::xopen 'xopen_read';
use Chj::IO::Command;

sub sorted_file {
    my ($path)=@_;
    Chj::IO::Command->new_sender("csort", "--", $path)
}

my $open= $opt_sorted ? \&sorted_file : \&xopen_read;

join_sorted map { scalar &$open ($_) } @args;

