#!/usr/bin/perl -w

# Mon Jun 14 14:23:41 MEST 2004 - 16:56
(my $email='pflanze%gmx,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);

use Chj::Unix::Daemonizer;
use Chj::xsysopen qw(xsysopen_append);
use Digest::MD5 "md5_hex";
use Chj::xperlfunc;
use Chj::Util::AskYN;
use Time::HiRes 'sleep';
use Chj::xtmpfile;
*Class::Array::clone=sub {my $self=shift;my $new=[@$self]; bless $new,ref $self} unless *Class::Array::clone{CODE};
use Chj::xhome;

my $usage;
my ($opt_stop, $opt_bg,$opt_nonice);
my $runbase="(only calculated if cmd/arguments given)";
my $basedir= xhome."/.daemonize-run";
our $maxwait=3;#seconds
our $logfile= "nohup.out";
our $opt_quiet;
our $opt_no_error_if_running;
our $signal=15; # SIGTERM

ARG:{
    while (@ARGV and $ARGV[0]=~ /^-(.*)/s) {
	my $opt=$1;
	shift @ARGV;
	if ($opt=~ /^-(.*)/s){
	    if (length $1) {
		if ($1 eq 'stop' or $1 eq 'kill') {
		    $opt_stop=1;
		} elsif ($1 eq 'bg') {
		    $opt_bg=1;
		} elsif ($1 eq 'quiet') {
		    $opt_quiet=1;
		} elsif ($1 eq 'no-nice') {
		    $opt_nonice=1;
		} elsif ($1 eq 'nice') {
		    $opt_nonice=0;
		} elsif ($1 eq 'signal') {
		    $signal=$ARGV[0]; shift @ARGV;
		    if (defined( $signal) and $signal=~ /^\d+\z/) {
			# ok
		    } else {
			$usage= "--signal option needs an integer argument";
			last ARG;
		    }
		} elsif ($1 eq 'out') {
		    $logfile=$ARGV[0]; shift @ARGV;
		    defined $logfile or do {
			$usage= "missing argument to --out option";
			last ARG;
		    };
		} elsif ($1 eq 'maxwait') {
		    $maxwait=$ARGV[0]; shift @ARGV;
		    if (defined $maxwait) {
			$maxwait =~ /^\d+(?:\.\d+)?$/
			  or die " --maxwait needs a number, got '$maxwait'";
		    } else {
			$usage= "missing argument to --maxwait option";
			last ARG;
		    };
		} elsif ($1 eq 'help') {
		    $usage="";
		    #last ARG; nope
		} elsif (($1 eq 'no-error-if-running') or ($1 eq 'no-error')) {
		    $opt_no_error_if_running=1;
		} else {
		    $usage= "unknown option '$1'";
		    last ARG;
		}
	    } else {
		# '--'
		last ARG;
	    }
	} else {
	    # single letter options
	    while (length $opt){
		my $o= substr $opt,0,1,"";
		if ($o eq 's' or $o eq 'k') {
		    $opt_stop=1;
		} elsif ($o eq 'b') {
		    $opt_bg=1;
		} elsif ($1 eq 'q') {
		    $opt_quiet=1;
		} elsif ($o eq 'N') {
		    $opt_nonice=1;
		} elsif ($o eq 'h') {
		    $usage="";
		    #last ARG; nope
		} else {
		    $usage= "unknown option '$o'";
		    last ARG;
		}
	    }
	}
    }
}

unless ($usage){ # no defined: only avoid if an *error* parsing the arguments has occurred.
    if (@ARGV) {
	my $hash= md5_hex join "\0",@ARGV;
	$runbase= "$basedir/$hash";
    } else {
	$usage="" # if not already set to "" anyway
    }
}


if (defined $usage) {
    print STDERR "$usage\n" if $usage;
    print "$myname [options] cmd arguments

  Better than 'nohup' (it is immune to other signals too), better than
  'batch' (it's quicker for you to notice what's happening), and also
  makes sure the same daemon/job is not started again if it is running
  already (hm, todo: should probably offer a way to override this?).
  You can wait at the shell for the daemon/job to finish, or can stop
  the 'waiter' (which doesn't stop the daemon/job itself). You can
  stop a running daemon/job by adding the --stop option.

  Options:
  (all of them must be listed before the cmd, multiple short options
   may be given together)
  -b|--bg     do not wait for the daemon to terminate
  -s|--stop|-k|--kill
              stop the previously started daemon; you have to give
              the exact same arguments.
              First kills with signal $signal, then if there are still
              processes after maxwait seconds, kills with SIGKILL.
  --signal N  use signal N instead of default $signal
  --maxwait N  change default of $maxwait sec to wait before sending SIGKILL
  -N|--no-nice  do not lower priority
  --out file  use file instead of 'nohup.out' for output (is opened in
              append mode)
  --quiet|-q  be quiet (do not output the pid of the daemon)
  --no-error-if-running|--no-error  do not report an error if the
              daemon is already running
              (with --quiet, suitable to be run repeatedly from crontab)
  --          terminate option processing

  Note: the pid file (and the output if nohup.out is not used)-- ehr?.
  for this run will be stored in the directory
   '$runbase'
  you should never have a need to look at it.

  Todo:
  - rundir cleanup function only removing those dirs
    for which no job is running anymore
  - option to start a second/third.. invocation of the same job?
  - to be usable for special users: use another dir than ~/.daemonize-run/

  (Christian Jaeger <$email>)
";
exit @_ ? 1 : 0;
}


(xmkdir $basedir, 0700) unless -d $basedir;
if (-d $runbase) {
    utime time,time,$runbase  # for future cleaner, to ignore too new directories (though runfile check should be done anyway too)
} else {
    xmkdir $runbase,0700;
    my $f= xtmpfile($runbase."/cmdline");
    $f->xprint ($_,"\0") for @ARGV;
    $f->xclose;
    $f->xputback(0444);
}
my $runfile= "$runbase/run";

if ($opt_stop) {
    my ($user,$hostname,$ip,$pid)=
      Chj::Unix::DaemonRunfile->new($runfile)->readfile;
    xkill -$signal,$pid;

  CHECK:{
	my $st=time;
	do {
	    sleep 0.1;
	    # try both the pid itself and the processgroup, since killing the pgroup using -$pid is not portable. tested on linux only, though.
	    if ((kill 0,$pid) # for portability only, if it helps even
		or
		(kill 0,-$pid)
	       ) {
		# redo
	    } else {
		last CHECK;
	    }
	    #warn "notyetfinished\n";
	} while ((time-$st)<$maxwait);
	kill -9,$pid and warn "not all processes exited, killed again with signal 9\n";
    }
}

else {
    my $daemonizer= Chj::Unix::Daemonizer->default->clone;
    $daemonizer->set_runpath($runfile);
    my $output;
    eval{
	$output= xsysopen_append $logfile,0600;
    };
    if ($@) {
	my $msg=$@;
	#$msg=~ s/:([^:]+) at/$1/;
	$msg=~ m/: *([^:]+) at/ and $msg=$1;
	warn "error opening '$logfile': $msg\n";
    }
    unless ($output) {
	my $tm="".localtime();
	$tm=~ s/://sg;
	$tm=~ tr/ /_/;
	my $path= "$runbase/$tm.out";
	$output= xsysopen_append $path;
	warn "output to '$path'\n";
    }
    $daemonizer->set_outputs($output);

    if (my $pid= $daemonizer->fork ($opt_no_error_if_running && sub {
					print STDERR "daemon already running\n"
					  unless $opt_quiet;
					exit 0
				    })) {
	print STDERR "daemon running as pid $pid",($opt_bg ? () : " (you can hit ctl-c now)"),"\n"
	  unless $opt_quiet;
	unless ($opt_bg) {
	    wait;
	    if ($?) {
		if ($?>255) {
		    print STDERR "daemon exited with return code ".($?>>8)."\n";
		} else {
		    print STDERR "daemon exited by signal $?\n";
		}
	    } else {
		print STDERR "daemon exited successfully.\n";
	    }
	    if (askyn "do you want to look at the output? "){
		xexec "less",$output->path;
	    }
	}
    } else {
	use POSIX 'nice';
	nice 5 unless $opt_nonice;
	xexec @ARGV;
    }
}

