#!/usr/bin/perl -w

# Tue Jun 10 18:06:11 CEST 2008
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

our $file= "/etc/debian_version";

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname [ versionstring ]

  Reads the contents of $file (or takes versionstring instead)
  and displays the result as both the number, release name, and
  release date if it's a stable release.

  Options:
  --list    list all known releases instead of picking the one from
            $file or the versionstring argument

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

{
    package CHJ::Release;
    use Class::Array -fields=> -publica=>
      qw(name
	 number
	 release_date
	 num_packages_binary
	 num_packages_source
	 num_developers
	 securitysupport_termination_date
	);
    sub new {
	my $class=shift;
	@_==7 or die;
	bless [@_],$class
    }
    sub as_string {
	my $s=shift;
	# should this give 'sid'? instead of lenny, for the name? OPEN
	"$$s[Name] (".($$s[Number]||"unknown release number").")"
    }
    sub fullinfo {
	my $s=shift;
	($s->as_string
	 ." ["
	 .join(", ",
	       map {
		   my $method=$_;
		   if (my $v= $s->$method) {
		       "$method: $v"
		   } else {
		       ()
		   }
	       } qw(release_date
		    num_packages_binary
		    num_packages_source
		    num_developers
		    securitysupport_termination_date
		   )
	      )
	."]")
    }
    end Class::Array;
}


# where to get this information from? No, *not* from
# http://www.us.debian.org/releases/
# since that's cheating about the release date of the stable release,
# and the links to the older releases won't give any date at all.

# http://www.debian.org/doc/manuals/project-history/ch-detailed.en.html

our $releases=
  [
   map { new CHJ::Release @$_ }
   # name, number, release_date, num_packages_binary, num_packages_source,
   #    num_developers,
   ["hamm", "2.0", "1998-07-XX", "1500+", undef, "400+", undef ],
   #   ^ is the 1500+ number for binary packages really?
   ["slink", "2.1", "1999-03-09", "~2250", undef, undef, undef ],
   # ^ first to include apt; Alpha + Sparc
   ["potato", "2.2", "2000-08-15", "3900+", "2600+", "450+", undef],
   # ^ PowerPC and ARM
   # Introduction of "Testing" distribution ("unstable" did already exist)
   ["woody", "3.0", "2002-07-19", "~8500", undef, "900+", undef ],
   # ^ first on DVD media
   ["sarge", "3.1", "2005-06-06", "~15000", undef, "1500+", undef ],
   # ^ *unofficial* AMD64 port; new installer (with RAID, XFS and LVM support)
   #   'aptitude as the selected tool for package management'
   ["etch", "4.0", "2007-04-08", "~18200", undef, "1030+", "2010-02-15" ], #hm muchless?.
   # ^ includes AMD64, but drops m68k (which was still in unstable, though)
   ["lenny", "5.0", "2009-02-14", ">23000", ">12000", undef, undef ],
   # ^ adds support for Marvell's Orion platform, .. now supports several Netbooks, .. also contains the build tools for Emdebian .. includes the new ARM EABI port, ..
   #  With the integration of X.Org 7.3 the X server autoconfigures itself with most hardware.
   #  Overall improvements for notebooks have been introduced, such as out of the box support of CPU frequency scaling.
   #  The availability and updates of OpenJDK, GNU Java compiler, GNU Java bytecode interpreter, Classpath and other free versions of Sun's Java technology, into Debian GNU/Linux 5.0 allow us to ship Java-based applications in Debian's "main" repository.
   #  Further improvements in system security include the installation of available security updates before the first reboot by the Debian Installer, the reduction of setuid root binaries and open ports in the standard installation, and the use of GCC hardening features in the builds of several security-critical packages. Various applications have specific improvements, too. PHP for example is now built with the Suhosin hardening patch.
   #  In addition to the regular installation media, Debian GNU/Linux can now also be directly used without prior installation. The special images used, known as live images, are available for CDs, USB sticks, and netboot setups. Initially, these are provided for the amd64 and i386 architectures only.

   # The last entry must/should always be the sid distribution (check
   # how it is being added as 'sid' to $release_by_name below) :
   ["squeeze", undef, undef, undef, undef, undef, undef ]
  ];

sub index_of_by {
    my ($list)=@_;
    sub {
	my ($method)= @_;
	+{
	  map {
	      my $k= $_->$method;
	      (defined $k) ?
		($k => $_)
		  : ()
	  } @$list
	 }
    }
}
*index_by= index_of_by($releases);

our $release_by_name= index_by ("name");
our $release_by_number= index_by ("number");
$$release_by_name{sid}= $$release_by_name{$$releases[-1][0]};
#^hm. http://www.debian.org/releases/ says that *testing* is called squeeze, unstable is sid. I'm somewhat confusing those here hm.

use Chj::Fileutil 'xCatfile';

{
    package CHJ::Release_with_key;
    use Class::Array -fields=> -publica=>
      qw(key
	 release);
    sub new {
	my $class=shift;
	@_==2 or die;
	bless [@_],$class
    }
    sub _delegate {
    	my ($methodname)=@_;
	sub {
	    my $s=shift;
	    $$s[Release]->$methodname(@_)
	}
    }
    no warnings;## agains 'used only once: possible typo'
    *as_string=_delegate ("as_string");
    #*fullinfo=_delegate ("fullinfo");
    sub fullinfo {
	my $s=shift;
	"[found: ".$s->key."] ".$$s[Release]->fullinfo
    }
    # no need for proxies of the fields right?
    end Class::Array;
}
sub make_release_with_key ($ $ ) {
    CHJ::Release_with_key->new(@_);
}

sub maybe_find_release {
    my ($key)= @_;
    $$release_by_number{$key} || $$release_by_name{lc $key} || do {
	$key=~ /^(\d+\.\d+)\.\d+\s*\z/s and $$release_by_number{$1}
    }
}

sub parseversion {
    my ($versionstring,$maybe_file)=@_;
    $versionstring=~ s/\s+\z//s;
    $versionstring=~ m/\s/s
      and die ("'"
	       .($file||$versionstring)
	       ."' contains whitespace not at the end");
    my @parts= split /\//,$versionstring;
    @parts <= 2 or die "'$file' contains more than one slash";
    my $r1= maybe_find_release ($parts[0]);
    if (@parts==2) {
	my $r2= maybe_find_release ($parts[1]);
	if ($r1 eq $r2) {
	    make_release_with_key (join(" / ",@parts),$r1)
	} else {
	    die ("'$file' contains contradicting information, "
		 ."leading to release "
		 .$r1->as_string
		 ." vs "
		 .$r2->as_string)
	}
    } else {
	if ($r1) {
	    make_release_with_key ($parts[0],$r1)
	} else {
	    die "couldn't find release for key '$parts[0]'";
	}
    }
}

sub list_releases {
    for my $r (@$releases) {
	print $r->fullinfo,"\n"
	  or die $!;
    }
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "list"=> sub {
	       list_releases();
	       exit;
	   },
	   ) or exit 1;
usage if @ARGV > 1;

print do {
    if (@ARGV) {
	parseversion ($ARGV[0])
    } else {
	parseversion (xCatfile $file)
    }
}->fullinfo,"\n";

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;

__END__

novo:~# cat /etc/debian_version
lenny/sid
