#!/usr/bin/perl -w

# Mon Jun  2 15:02:18 CEST 2008
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);

use Chj::xperlfunc;
use Chj::singlequote "singlequote_sh";

sub _xxsystem {
    use Data::Dumper "Dumper";
    print "xxsystem ", Dumper \@_;
    xxsystem @_;
}

our $commit_filter_script__skip_empty_commits=
  'if [ z"$1" = z"$(git rev-parse "$3"^{tree})" ]
      then skip_commit "$@"
      else git commit-tree "$@"; fi';

our $make_filter= sub {
    my ($index_filter_thunk, $commit_filter_thunk)=@_;
    sub {
	# @ARGV being the list of files to remove
	xxsystem(
		 'git',
		 'filter-branch',

		 '--index-filter',
		 &$index_filter_thunk,

		 '--commit-filter',
		 &$commit_filter_thunk,
		);
    }
};

our $removefiles= &$make_filter
  (
   sub {
       ('git update-index '
	.join(' ',
	      map {
		  "--remove ".singlequote_sh($_)
	      } @ARGV)
	.' HEAD')
   },
   sub { $commit_filter_script__skip_empty_commits}
  );

our $removedirs= &$make_filter
  (
   sub {
       ('git rm --cached -r ' #does this work out?
	.join(' ',
	      map {
		  singlequote_sh ($_)
	      }
	      @ARGV)
	.' ' # no HEAD necessary to tell?
	.' || true ' # since otherwise git rm fails and the whole thing will fail too
	)
   },
   sub { $commit_filter_script__skip_empty_commits}
  );

our $remove_perlmatch= &$make_filter
  (
   sub {
       @ARGV==1
	 or die "$myname: expecting 1 argument, the perl code for the test, but got ".@ARGV." arguments\n";
       my ($perlcode)=@ARGV;
       ('git ls-files -z |'
	.'perl -wn -0 -l0 -e '.singlequote_sh ($perlcode)
	# ^note: *both* the -0 and -l0 flags are necessary: the former
	# somehow for input line handling (-l only seems to have an
	# effect on chomp, not on file splitting?), the latter for
	# chomping and printing.
	.'|xargs -0 git rm --cached'
       )
   },
   sub { $commit_filter_script__skip_empty_commits}
  );


sub CmdSetter ( $ );#heh
our $cmds=
  [
   ["remove-files" => CmdSetter($removefiles),
    "remove all given file paths from repo (including their commit if empty)"],
   ["remove-dirs" => CmdSetter ($removedirs),
    "remove all files in the given dir paths (including their commit if empty)"],# basically just a recursive version of the remove-files thing. wouldn't that message be too long?
   ["remove-perlmatch" => CmdSetter ($remove_perlmatch),
    "remove all files whose paths are printed by the given perl code; like 'print if m|someregex|' is enough, perl is run with flags to automatically strip and add \\0 path separation bytes"],
  ];

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    my $cmdsstr= join("",
		      map {
			  my ($nam,$ptr,$desc)=@$_;
			  "   --$nam  $desc\n"
		      }
		      @$cmds);
    print "$myname --command [ commandarguments ]

$cmdsstr
  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

our $command;
sub CmdSetter ( $ ) {
    my ($cmd)=@_;
    sub {
	if ($command) {
	    usage "can't give more than one command, currently";
	}
	$command= $cmd
    }
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   map {
	       @$_[0,1]
	   } @$cmds
	  ) or exit 1;
usage unless @ARGV;

&$command;


#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
