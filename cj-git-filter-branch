#!/usr/bin/perl -w

# Mon Jun  2 15:02:18 CEST 2008
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);

use Chj::xperlfunc;
use Chj::singlequote qw(singlequote_sh singlequote);

sub _xxsystem {
    use Data::Dumper "Dumper";
    print "xxsystem ", Dumper \@_;
    xxsystem @_;
}

our $commit_filter_script__skip_empty_commits=
  'if [ initial = "${3-initial}" ]; then
      if [ z"$1" = z"4b825dc642cb6eb9a060e54bf8d69288fbee4904" ]; then
         skip_commit "$@"
      else
         git commit-tree "$@"
      fi
   else
      if [ znot_a_merge = z"${5-not_a_merge}" ]; then
	 if [ z"$1" = z"$(git rev-parse "$3"^{tree})" ]; then
	    skip_commit "$@"
	 else
	    git commit-tree "$@"
	 fi
      else
         # always commit merges, so that they end up in the right place. hm.
         # rather: this is a cheap way of not having to check for more arguments above.
echo "seeing a merge: $@" >&2
         git commit-tree "$@"
      fi
   fi';

our $opt_dry;

our $make_filter= sub {
    my ($index_filter_thunk, $commit_filter_thunk)=@_;
    sub {
	# @ARGV being the list of files to remove
	my @cmd= (
		  'git',
		  'filter-branch',

		  '--index-filter',
		  &$index_filter_thunk,

		  '--commit-filter',
		  &$commit_filter_thunk,
		 );
	if ($opt_dry) {
	    use Chj::singlequote 'singlequote_many';
	    print "would call: ".singlequote_many(@cmd)."\n" or die $!;
	} else {
	    xxsystem @cmd;
	}
    }
};

our $removefiles= &$make_filter
  (
   sub {
       ('git update-index '
	.join(' ',
	      map {
		  "--remove ".singlequote_sh($_)
	      } @ARGV)
	.' HEAD')
   },
   sub { $commit_filter_script__skip_empty_commits}
  );

our $opt_quiet_rm;

our $removedirs= &$make_filter
  (
   sub {
       ('git rm --cached '.($opt_quiet_rm ? "--quiet":"").' -r ' #does this work out?
	.join(' ',
	      map {
		  singlequote_sh ($_)
	      }
	      @ARGV)
	.' ' # no HEAD necessary to tell?
	.' || true ' # since otherwise git rm fails and the whole thing will fail too
	)
   },
   sub { $commit_filter_script__skip_empty_commits}
  );

our $_remove_perlmatch= sub {
    my ($perlcode)=@_;
    my $shellcode=
      ('git ls-files -z |'
       .'perl -wn -0 -l0 -e '.singlequote_sh ($perlcode)
       # ^note: *both* the -0 and -l0 flags are necessary: the former
       # somehow for input line handling (-l only seems to have an
       # effect on chomp, not on file splitting?), the latter for
       # chomping and printing.
       .'|xargs -0 --no-run-if-empty git rm --cached '.($opt_quiet_rm ? "--quiet":"")
      );
    $shellcode
};

our $remove_perlmatch= &$make_filter
  (
   sub {
       @ARGV==1
	 or die "$myname: expecting 1 argument, the perl code for the test, but got ".@ARGV." arguments\n";
       &$_remove_perlmatch ($ARGV[0])
   },
   sub { $commit_filter_script__skip_empty_commits}
  );

use Chj::xrealpath;
our $remove_all_but_those_in= &$make_filter
  (
   sub {
       @ARGV==1
	 or die "$myname: expecting 1 argument, the path containing the filelist, but got ".@ARGV." arguments\n";
       my ($path)=@ARGV;
       my $realpath= xrealpath $path;
       my $code= ('BEGIN { { local $/="\n"; open my $in, "<",'
		  .singlequote($realpath)
		  .' or die; %want=map { chomp; $_=>1} <$in>; close $in or die; } } print unless $want{$_}');
       &$_remove_perlmatch ($code)
   },
   sub { $commit_filter_script__skip_empty_commits}
  );

our $cmds=
  [
   ["remove-files" => $removefiles,
    "remove all given file paths from repo (including their commit if empty)"],
   ["remove-dirs" => $removedirs,
    "remove all files in the given dir paths (including their commit if empty)"],# basically just a recursive version of the remove-files thing. wouldn't that message be too long?
   ["remove-perlmatch" => $remove_perlmatch,
    "remove all files whose paths are printed by the given perl code; like 'print if m|someregex|' is enough, perl is run with flags to automatically strip and add \\0 path separation bytes"],

   ["remove-all-but-those-in" => $remove_all_but_those_in,
    "remove all files except those which are listed (one path per line) in the file with the given path"],
  ];

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    my $cmdsstr= join("",
		      map {
			  my ($nam,$ptr,$desc)=@$_;
			  "   --$nam  $desc\n"
		      }
		      @$cmds);
    print "$myname --command [ commandarguments ]

$cmdsstr

  ATTENTION: THIS SCRIPT OR PROCEDURE SUCKS HORRIBLY.
  - it will not drop branches if they got totally empty, but instead
    add the initial commit of that branch (with empty tree!) to
    the next newer commit in the new history (making it a merge commit,
    even if it wasn't a merge originally)
  - it will not treat the initial commit.


  Options:
  --quiet-rm    pass quiet option to git rm
  --dry-run     show what git filter-branch instance would be run.

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

our $command;
use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "quiet-rm"=> \$opt_quiet_rm,
	   "dry-run"=> \$opt_dry,
	   map {
	       my($key,$cmd)= @$_[0,1];
	       ($key,
		sub {
		    if ($command) {
			usage "can't give more than one command, currently (parsing option --$key)";
		    }
		    $command= $cmd
		})
	   } @$cmds
	  ) or exit 1;
usage unless @ARGV;

&$command;


#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
