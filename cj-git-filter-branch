#!/usr/bin/perl -w

# Mon Jun  2 15:02:18 CEST 2008
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);

use Chj::xperlfunc;
use Chj::singlequote qw(singlequote_sh singlequote);

our $opt_ignore_empty_merge_commits=1;##XX used before option parsing, so not really an opt
our $commit_filter_script__skip_empty_commits=
  '
   if [ initial = "${3-initial}" ]; then
      if [ "$1" = "4b825dc642cb6eb9a060e54bf8d69288fbee4904" ]; then
         skip_commit "$@"
      else
         git commit-tree "$@"
      fi
   else
      if [ znot_a_merge = z"${5-not_a_merge}" ]; then
	 if [ "$1" = "$(git rev-parse "$3"^{tree})" ]; then
	    skip_commit "$@"
	 else
	    git commit-tree "$@"
	 fi
      else
         echo "seeing a merge: $@" >&2
   '.($opt_ignore_empty_merge_commits ?
  '      my_tree="$1"
         shift

         declare -a allparents=()
         for p in "$@"; do
             if [ ! x"$p" = x"-p" ]; then
                 allparents+=("$p")
             fi
         done

         declare -a sametreeparents=()
         declare -a notsametreeparents=()
         for p in "${allparents[@]}"; do
             if [ "$my_tree" = "$(git rev-parse "$p"^{tree})" ]; then
                 sametreeparents+=("$p")
             else
                 notsametreeparents+=("$p")
             fi
         done

         if [ "${#sametreeparents[@]}" = 1 ]; then
             sametreeparent="${sametreeparents[0]}"
             declare -a neededparents=()
             for p in "${notsametreeparents[@]}"; do
                 set +e
                 mb=$(git merge-base "$sametreeparent" "$p")
                 rc=$?
                 set -e
                 if [ $rc = 0 ]; then
                     if [ ! "$mb" = "$p" ]; then
                         neededparents+=("$p")
                     fi
                 elif [ $rc = 1 ]; then
                     echo "non-common ancestors, keeping merge" >&2
                 else
                     die "git merge-base had a problem"
                 fi
             done

             if [ "${#neededparents[@]}" = 0 ]; then
                 skip_commit "$my_tree" "$@"
             else
                 # still drop the parents that have no effect, ok?
                 declare -a newargs=(-p "$sametreeparent")
                 for p in "${neededparents[@]}"; do
                     newargs+=(-p)
                     newargs+=("$p")
                 done
                 git commit-tree "$my_tree" "${newargs[@]}"
             fi
         else
             git commit-tree "$my_tree" "$@"
	 fi'
      :
  '      git commit-tree "$@"').'
      fi
   fi
';

our $opt_dry;
our $opt_rev;
our $opt_f;

our $make_filter= sub {
    my ($index_filter_thunk, $commit_filter_thunk)=@_;
    sub {
	# @ARGV being the list of files to remove
	my @cmd= (
		  'git',
		  'filter-branch',
		  ($opt_f ? "-f" : ()),

		  '--index-filter',
		  &$index_filter_thunk,

		  '--commit-filter',
		  &$commit_filter_thunk,

		  ($opt_rev ? $opt_rev : ()),

		 );
	if ($opt_dry) {
	    use Chj::singlequote 'singlequote_many';
	    print( "would call xxsystem with:\n "
		   .
		   join (" \\\n ",
			 map {singlequote_sh($_)} @cmd)
		   ."\n" )
	      or die $!;
	} else {
	    xxsystem @cmd;
	}
    }
};

our $removefiles= &$make_filter
  (
   sub {
       ('git update-index '
	.join(' ',
	      map {
		  "--remove ".singlequote_sh($_)
	      } @ARGV)
	.' HEAD')
   },
   sub { $commit_filter_script__skip_empty_commits}
  );

our $opt_quiet_rm;

our $removedirs= &$make_filter
  (
   sub {
       ('git rm --cached '.($opt_quiet_rm ? "--quiet":"").' -r ' #does this work out?
	.join(' ',
	      map {
		  singlequote_sh ($_)
	      }
	      @ARGV)
	.' ' # no HEAD necessary to tell?
	.' || true ' # since otherwise git rm fails and the whole thing will fail too
	)
   },
   sub { $commit_filter_script__skip_empty_commits}
  );

our $_remove_perlmatch= sub {
    my ($perlcode)=@_;
    my $shellcode=
      ('git ls-files -z |'
       .'perl -wn -0 -l0 -e '.singlequote_sh ($perlcode)
       # ^note: *both* the -0 and -l0 flags are necessary: the former
       # somehow for input line handling (-l only seems to have an
       # effect on chomp, not on file splitting?), the latter for
       # chomping and printing.
       .'|xargs -0 --no-run-if-empty git rm --cached '.($opt_quiet_rm ? "--quiet":"")
      );
    $shellcode
};


sub die_expecting {
    my ($msg)=@_;
    die "$myname: expecting $msg, but got ".@ARGV." arguments\n";
}

our $remove_perlmatch= &$make_filter
  (
   sub {
       @ARGV==1
	 or die_expecting "1 argument, the perl code for the test";
       &$_remove_perlmatch ($ARGV[0])
   },
   sub { $commit_filter_script__skip_empty_commits}
  );

use Chj::xrealpath;
our $opt_prefix;
our $remove_all_but_those_in= &$make_filter
  (
   sub {
       @ARGV==1
	 or die_expecting "1 argument, the path containing the filelist";
       my ($path)=@ARGV;
       my $realpath= xrealpath $path;
       my $code= ('BEGIN { { local $/="\n";'.
		  'open my $in, "<",'.singlequote($realpath).' or die;'.
		  '%exclude=map { chomp; $_=>1} <$in>;'.
		  'close $in or die; } } '.
		  ($opt_prefix ?
		   'use Chj::xperlfunc "dirname";'.
		   ('sub exclude {'.
		    '   my ($p)=@_;'.
		    '   if ($p eq "" or $p eq "." or $p eq "/") {'.
		    '      0'.
		    '   } else {'.
		    '      $exclude{$p} or exclude(dirname $p)'.
		    '   }'.
		    '}'.
		    'print unless exclude($_)')
		   :
		   'print unless $exclude{$_}')
		 );
       &$_remove_perlmatch ($code)
   },
   sub { $commit_filter_script__skip_empty_commits}
  );

our $cmds=
  [
   ["remove-files" => $removefiles,
    "remove all given file paths from repo (including their commit if empty)"],
   ["remove-dirs" => $removedirs,
    "remove all files in the given dir paths (including their commit if empty)"],# basically just a recursive version of the remove-files thing. wouldn't that message be too long?
   ["remove-perlmatch" => $remove_perlmatch,
    "remove all files whose paths are printed by the given perl code; like 'print if m|someregex|' is enough, perl is run with flags to automatically strip and add \\0 path separation bytes"],

   ["remove-all-but-those-in" => $remove_all_but_those_in,
    "remove all files except those which are listed (one path per line) in the file with the given path (if entries should match directories where the path is in, also give --prefix)"],
  ];

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    my $cmdsstr= join("",
		      map {
			  my ($nam,$ptr,$desc)=@$_;
			  "   --$nam  $desc\n"
		      }
		      @$cmds);
    print "$myname --command [ commandarguments ]

$cmdsstr

  ATTENTION: THIS SCRIPT OR PROCEDURE SUCKS HORRIBLY.
  - it will not drop branches if they got totally empty, but instead
    add the initial commit of that branch (with empty tree!) to
    the next newer commit in the new history (making it a merge commit,
    even if it wasn't a merge originally)
  - it will not treat the initial commit.


  Options:
  --quiet-rm    pass quiet option to git rm
  --dry-run     show what git filter-branch instance would be run.
  --rev         rev-list option(not plural, hm), passed to git filter-branch
                to specify the range to be filtered.
  -f|--force    pass -f option to filter-branch (ingore those pesky refs/original/)

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

our $command;
use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "quiet-rm"=> \$opt_quiet_rm,
	   "dry-run"=> \$opt_dry,
	   "rev=s"=> \$opt_rev,
	   "f|force"=> \$opt_f,
	   "prefix"=> \$opt_prefix,
	   map {
	       my($key,$cmd)= @$_[0,1];
	       ($key,
		sub {
		    if ($command) {
			usage "can't give more than one command, currently (parsing option --$key)";
		    }
		    $command= $cmd
		})
	   } @$cmds
	  ) or exit 1;
usage unless @ARGV;

&$command;


#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
