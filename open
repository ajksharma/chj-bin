#!/usr/bin/perl -w

# cj Wed Jul 31 16:35:48 MEST 2002 / Thu, 18 Jan 2007 09:17:34 +0100

use strict;

$0=~ /([^\/]+)$/s or die "?";
my $myname=$1;
sub usage {
    print "$myname file(s)
  Meant to be used from command line (to act same as clicking on a file in dfm,
  except that it tries not to open xterm's around commands).
";
exit @_;
}

our $DEBUG;
my @files;
for (my $i=0; $i<=$#ARGV; $i++) {
    local $_=$ARGV[$i];
    if (/^--?h(elp)?$/) {
        usage
    } elsif (/^--?d(ebug)?$/) {
        $DEBUG=1;
    } elsif ($_ eq '--') {
        push @files, @ARGV[$i+1..$#ARGV];
        last;
    } elsif (/^-/) {
        warn "$myname: Unknown option '$_'\n";
        usage(1)
    } else {
        push @files, $_
    }
}
usage unless @files;

use POSIX 'ENOENT';

sub maybe_open_file {
    my ($path)=@_;
    my $in;
    open $in,"<",$path or do {
	if ($! == ENOENT) {
	    return
	} else {
	    die "Could not open '$path': $!\n";
	}
    };
    [$in,$path]
}

{
    package _Map;
    use Class::Array -fields=> -publica=>
      (
       '_tuples',
       'filepath',
      );
    sub new {
	my $class=shift;
	bless[@_],$class;
    }
    sub tuples {
	my $s=shift;
	@{$$s[_Tuples]}
    }
    end Class::Array;
}

sub maybe_read_map_from_dfmext {
    my @map;
    my ($in,$found_path)= @{
	(maybe_open_file ("$ENV{HOME}/.dfmext")
	 or
	 maybe_open_file ("/home/chris/.dfmext")
	 or return)
    };
    while(<$in>){
	next if /^\s*#/;
	my ($match,$cmd)=(split /;/)[0,2];
	next if $match=~ m|/$|s; # folder match rule -> nothing implemented yet
	$match=~ s/\./\\./sg;
	$match=~ s/\*/.*/sg;
	# quote other nonfunctional but regexsyntax chars
	$match=~ s/([+])/\\$1/sg;
	my @cmd= split /\s+/,$cmd;
	my $no_bg;
	if (@cmd and $cmd[0] eq "xterm" and $cmd[1] eq "-e") {
	    @cmd= @cmd[2,$#cmd];
	    $no_bg=1;
	}
	push @map,[
		   qr/^$match$/s,
		   \@cmd,
		   $no_bg,
		  ];
    }
    close $in or die "Error on close: $!";
    new _Map \@map,$found_path;
}

our $map= maybe_read_map_from_dfmext
  or die "no filetype map found";


FILE: for my $file (@files) {
    #my $suf= lc(/\.([^.]+)$/s);
    my ($filename)= $file=~ m|([^/]+)$|s or do{ warn "Ignoring '$file'\n"; next};
    for ($map->tuples){
	local our ($regex,$cmd,$no_bg)=@$_;
        if ($filename=~ $regex){
            warn " $regex MATCHED!\n" if $DEBUG;
	    if ($$cmd[0] eq '!0!') {
		require Data::Dumper;
		die "security problem: not allowed to start argument as command (better change your map file?!) : ".Data::Dumper::Dumper ($cmd)
	    }
            local our @exec= map { $_ eq '!0!' ? $file : $_ } @$cmd;
	    my $ex=sub {
		## "session id stuff!" (?)
		exec @exec; die "Could not execute '".join("', '",@exec)."'\n";
	    };
	    #use Chj::repl; repl;
            my $pid=fork;
            defined $pid or die "Could not fork: $!\n";
            if ($pid){
		if ($no_bg) {
		    #waitpid 0,$pid or die $!;
		    waitpid $pid,0 or die $!; #grrr.
		} else {
		    next FILE;
		}
            } else {
		&$ex;
            }
        } else {
            warn " $regex did not match\n" if $DEBUG;
        }
    }
    my $mapfile= $map->filepath;
    warn "$myname: could not find an entry in '$mapfile' matching the filename '$filename'\n";
}

