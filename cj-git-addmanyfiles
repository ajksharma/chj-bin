#!/usr/bin/perl -w

# Mon Aug 18 13:34:20 CEST 2008
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

our $nfiles= 30000;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname dir

  Add *and commit* many files, and do it in pieces, so every $nfiles a
  commit is done and then a git-repack before continuing.

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   ) or exit 1;
usage unless @ARGV;


# how to deliver items, "with continue", ?
# lazy or....?
# insideout, sigh.

{
    package CJGIT::Filestream;
    # recursively returns all file system items except directories
    # (depth-first)
    use Class::Array -fields=>
      -publica=>
	("curfd",
	 #"dirstack", ehr
	 "fdstack",
	 #ah still need dirstack. for giving paths out of next_path
	 "dirstack",
	);
    use Chj::xopendir;
    use Chj::xperlfunc ':all'; # xlstat
    sub new {
	my $class=shift;
	our ($basedir)=@_;
	my $s= $class->SUPER::new;
	$$s[Curfd]= xopendir $basedir;
	$$s[Fdstack]= [];
	$$s[Dirstack]= [$basedir];
	$s
    }
    sub next_path {
	my $s=shift;
	if (defined (my $item= $$s[Curfd]->xnread)) {
	    my $path= join("/", @{$$s[Dirstack]}, $item);
	    my $stat= xlstat $path;
	    if ($stat->is_dir) {
		local $$s[Curfd]= xopendir $path;
		# (missing linked lists here of course)
		local $$s[Dirstack]= [ @{$$s[Dirstack]}, $item ];
		local $$s[Fdstack]= [ @{$$s[Fdstack]}, $$s[Curfd] ];
		$s->next_path
	    } else {
		$path
	    }
	} else {
	    undef
	}
    }
}

#use Chj::ruse;
use Chj::Backtrace; use Chj::repl; #repl;

sub addmanyfiles ( $ ) {
    my ($path)=@_;
    our $stream= CJGIT::Filestream->new($path);
    repl;
}


for my $path (@ARGV) {
    addmanyfiles $path
}

