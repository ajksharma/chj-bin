#!/usr/bin/perl -w

# Son Jun  3 22:12:16 CEST 2007
(my $email='pflanze%gmx,ch')=~ tr/%,/@./;

use strict;

our $filecmd= "/usr/bin/file";

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname originalprogram [options] possibly-gzipped-file

  if one file is given and it is compressed, uncompress it into a tempfile
  and call originalprogram with the original options.

  See ${mydir}gv and ${mydir}xpdf wrappers, they are calling me.

  (Christian Jaeger <$email>)
";
    exit (@_ ? 1 : 0);
}

@ARGV or usage;
usage if $ARGV[0]=~ /^--?h(elp)?$/;

our $origprog=shift @ARGV;

our @args= map {
    # the argument, and whether it is a filearg
    [ $_, not /^-/ ]
} @ARGV;

our @fileargs= grep {
    $$_[1]
} @args;

use Chj::xperlfunc;
use Chj::Unix::SuperPATH;

sub normalexe {
#    &{(do{ # really, I'm not joking, those *3* layers around the if are necessary.
&{ # ah no, this works, too. but once you decide (usually you have to,right???!) to use do, then you have to wrap it up in two additional layers. Funny, why is the do not necessary here?. (*because* it would take 3 layers otherwise?)
	if ($origprog=~ m|/|) {
	    \&xexec
	} else {
	    \&xsuperexec
	}
}
#    })}
($origprog,@ARGV);
}

use Chj::IO::Command;
use Chj::xtmpfile;
use Chj::xopen 'xopen_read';
use Chj::xpipeline 'xreceiverpipeline_with_out_to';
use Chj::xrealpath;
use Chj::xtmpdir;
use Chj::xperlfunc 'basename';

our $TMPDIR="/tmp";

sub uncompress {
    my ($file)=@_;
    $file= xrealpath $file;
    my $c=  Chj::IO::Command->new_sender($filecmd,"--",$file);
    my $cnt=$c->xcontent;
    $c->xxfinish;
    my $decmd= do {
	if ($cnt=~ /: gzip compressed/) {
	    ["gunzip"]
	} elsif ($cnt=~ /: bzip2 compressed/) {
	    ["bunzip2"]
	} elsif ($cnt=~ /: XZ compressed/) {
	    ["xz", "-d"]
	} else {
	    undef
	}
    };
    $decmd and do {
	#wiedermal  pipelinenötig
	my $f= xopen_read $file;
	my $tdir= xtmpdir $TMPDIR."/"; # do not use lengthy program path. Well, I really meant to say this to xtmpfile; but there I'm now using the (exact) filename anyway (with xputback).
	my $filename= basename $file;
	##ugly, shouldn't this be done by the decompression detection routine.
	$filename=~ s/\.(gz|bz2)\z//is;
	##/ugly
	my $t= xtmpfile "$tdir/$filename";
	my $r= xreceiverpipeline_with_out_to($t, $decmd);
	$f->xsendfile_to($r);
	$r->xxfinish;
	$t->xclose;#ps ich gebe $t hin aber in wahrheit tut es fd gell geben ?.
	$t->xputback(0644);#hm forever--mask or perms?
	## what with the cleanup??.switched off now  ? I think. rite?.
	## but the wrapper object will need to make some ordering anyway so don't bother.
	bless [$tdir, $t->path], "CJ_uncompress_run::Tmpfile"
    }
}

{
    package CJ_uncompress_run::Tmpfile;
    # fields [tdir, filepath]
    sub path {
	my $s=shift;
	$$s[1]
    }
    sub DESTROY {
	my $s=shift;
	unlink $s->path;
	# let the tmpdir clean itself up by itself.
    }
}

if (@fileargs==1) {
    my $file= $fileargs[0][0];
    if (my $uncompressed= uncompress $file) {
	xxsystem $origprog, map {
	    if ($$_[1]) {
		$uncompressed->path
	    } else {
		$$_[0]
	    }
	} @args;
    } else {
	normalexe;
    }
} else {
    normalexe;
}

