#!/usr/bin/perl -w

# Tue Nov 11 11:18:22 CET 2008
(my $email='christian-novo%jaeger,mine,nu')=~ tr/%,/@./;

use strict;


$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);

our $datadir= do{$ENV{HOME}|| die "missing HOME env var"}."/.$myname";
our $default_interface="eth0";

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname [ interface(s) ]

  Look at the interfaces' IP's, if different from the last run of
  $myname, look them up in reverse dns and add them to the database
  (with the given environment: '$datadir').

  If no interfaces are given, just look at all relevant interfaces
  (i.e. excluding 'lo' and interface aliases) which are up.

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   ) or exit 1;

sub debug {
    print STDERR "$myname: ",join(" ", @_),"\n"
      if $verbose;
}

mkdir $datadir, 0700;

sub data_subdir ( $ ) {
    my ($subdir)=@_;
    my $path="$datadir/$subdir";
    mkdir $path;
    $path
}

# use the list mode of is_if_up, but filter out irrelevant entries right.
#multiple methods. thusmake it a package.blessedobj.
{
    package CHJ::recordip::ifaces;
    use Class::Array -fields=>
      -publica=>
	(
	 'opt_iface_selection',
	 'hash',
	);
    use Chj::is_if_up 'is_if_up';
    sub new_now {
	my $class=shift;
	my $opt_iface_selection = @_ ? +{ map { $_=>1 } @_ } : undef;
	my $s= $class->new;
	$$s[Opt_iface_selection]= $opt_iface_selection;
	$s->init;
	$s
    }
    sub init {
	my $s=shift;
	my $opt_iface_selection = $$s[Opt_iface_selection];
	my $hash=
	  +{
	    map {
		my ($name,$ip)=@$_;
		(($opt_iface_selection ?
		  $$opt_iface_selection{$name}
		  :
		  $s->is_relevant_interface ($name)) ?
		 @$_
		 :
		 ())
	    } is_if_up
	   };
	#^ ok doesn't check for doubles. but *should* not happen right?
	# well perl _should_ have a hash constructor which complains.(...)
	$$s[Hash]=$hash;
    }
    sub interfacenames {
	my $s=shift;
	keys %{$$s[Hash]}
    }
    sub ips {
	my $s=shift;
	map {
	    $$s[Hash]{$_}
	} $s->interfacenames
    }
    sub if_and_ip_s {
	my $s=shift;
	map {
	    [$_, $$s[Hash]{$_}]
	} $s->interfacenames
    }
    sub Mk_sortedstringie {
	my ($method)=@_;
	sub {
	    my $s=shift;
	    join ("|",sort $s->$method)
	}
    }
    sub interfacenames_string;
    *interfacenames_string= Mk_sortedstringie ("interfacenames");
    sub ips_string;
    *ips_string= Mk_sortedstringie ("ips");
    sub maybe_ip_of_interface {
	my $s=shift;
	my ($interface)=@_;
	$$s[Hash]{$interface}
    }
    sub ip_of_interface {
	my $s=shift;
	my ($interface)=@_;
	$s->maybe_ip_of_interface ($interface)
	  or die "interface not up or known: '$interface'";
    }
	
    ## the one special thing for this here. otherwise this code could/should go into Chj::is_if_up or so right?.todo.
    #'parametrization':
    sub is_relevant_interface {
	my $proto=shift;
	my ($if)=@_;
	not ($if eq "lo"
	     or
	     $if=~ /:/)
    }
}


use Chj::FileStore::MIndex;
our $ip_store= Chj::FileStore::MIndex->new(data_subdir ("ip_store"));
use Chj::FileStore::PIndex;
our $attr_store= Chj::FileStore::PIndex->new (data_subdir ("attr_store"));

use Chj::DNS 'ip_reverse_lookup';

# ip -> domainname.

sub _resolveadd ($ ) {
    my ($ip)=@_;
    $ip_store->add ($ip,
		    ip_reverse_lookup($ip));
}



sub recordips {
    my (@interfaces)=@_;
    my $ifaces= CHJ::recordip::ifaces->new_now (@interfaces);
    my $ips_string= $ifaces->ips_string;

    my $resolveadd= sub {
	for my $if_and_ip ($ifaces->if_and_ip_s) {
	    my ($interface,$ip)= @$if_and_ip;
	    debug "interface '$interface' is at ip '$ip'";
	    _resolveadd ($ip);
	} # "else" the missing interfaces. also an old  pattern.
	  # debug "interface '$interface' is not up"
          # [todo]
	$attr_store->set ("lastips",$ips_string);
    };

    if (my $lastips_string= $attr_store->maybe_get("lastips")) {
	if ($lastips_string eq $ips_string) {
	    debug "lastips is '$ips_string' already, so do not look-up&add-reverse-entry again";
	} else {
	    debug "ips '$ips_string' is different from lastips '$lastips_string'";
	    &$resolveadd
	}
    } else {
	debug "no lastip entry yet";
	&$resolveadd
    }
}

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
#__END__

if (@ARGV) {
    recordips @ARGV
} else {
    recordips ()
}

