#!/usr/bin/perl -w

# Tue Nov 11 11:18:22 CET 2008
(my $email='christian-novo%jaeger,mine,nu')=~ tr/%,/@./;

use strict;


$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);

our $datadir= do{$ENV{HOME}|| die "missing HOME env var"}."/.$myname";
our $default_interface="eth0";

sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname [ interface ]

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   ) or exit 1;
#usage if @ARGV ;

sub debug {
    print STDERR "$myname: ",join(" ", @_),"\n"
      if $verbose;
}

mkdir $datadir, 0700;

use Chj::is_if_up 'is_if_up';
use Net::DNS;
#^ hab ich nid mal n wrapper gemacht? ah nur Chj/DNS/Mx*
my $resolver= Net::DNS::Resolver->new;
sub mk_lookup {
    #my ($type, $method)=@_;
    #hm interessant  weil ich bei rdatastr noch . wegnehmen muss, muss ich eignen code haben.
    my ($type,$fn)=@_;
    sub ( $ ) { #wirkt das oder nid?.
	my ($ip)=@_;
	my $query= $resolver->search ($ip); #ok?
	if ($query) {
	    my @res;
	    local our $rr;
	    for $rr ($query->answer) { #not answers. sowat stupid~.
		#use Chj::repl; repl;
		next unless $rr->type eq $type;
		push @res, &$fn ($rr);
	    }
	    wantarray ? @res : $res[0]
	} else {
	    debug "ip_reverse_lookup for ip '$ip' failed";
	    ()
	}
    }
}

sub ip_forward_lookup ( $ ); # against 'only used once' warning. grr.
*ip_forward_lookup= mk_lookup("A",sub { $_[0]->address });
*ip_reverse_lookup= mk_lookup("PTR",sub {
				  my $res= $_[0]->rdatastr;
				  $res=~ s/\.\z//
				    or die "no match for dot at end in '$res'";
				  $res
			      });

#^ TODO move to a lib.

sub data_subdir ( $ ) {
    my ($subdir)=@_;
    my $path="$datadir/$subdir";
    mkdir $path;
    $path
}

use Chj::FileStore::MIndex;
our $ip_store= Chj::FileStore::MIndex->new(data_subdir ("ip_store"));
use Chj::FileStore::PIndex;
our $attr_store= Chj::FileStore::PIndex->new (data_subdir ("attr_store"));


# ip -> domainname.

sub _resolveadd ($ ) {
    my ($ip)=@_;
    $ip_store->add ($ip,
		    ip_reverse_lookup($ip));
}

sub recordip ( $ ) {
    my ($interface)=@_;
    if (my $ip= is_if_up $interface) {
	debug "interface '$interface' is at ip '$ip'";
	my $resolveadd=
	  sub {
	      _resolveadd ($ip);
	      $attr_store->set ("lastip",$ip);
	  };
	if (my $lastip= $attr_store->maybe_get("lastip")) {
	    if ($lastip eq $ip) {
		debug "lastip is '$ip' already, so do not look-up&add-reverse-entry again";
	    } else {
		debug "ip is different from lastip '$lastip'";
		&$resolveadd
	    }
	} else {
	    debug "no lastip entry yet";
	    &$resolveadd
	}
    } else {
	debug "interface '$interface' is not up"
    }
}

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
#__END__

if (@ARGV) {
    recordip $_ for @ARGV
} else {
    recordip $default_interface
}

