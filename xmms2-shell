#!/usr/bin/perl -w

# Sun Jul 20 13:02:13 CEST 2008
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname ..

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   ) or exit 1;
#usage unless @ARGV;

use Term::ReadLine;
use Chj::xperlfunc;

use Class::Array -fields=>
  -publica=>
  (
   "prompt",
  );

our $self=[];
$$self[Prompt]="xmms2 ";

sub run {
    local our $term = $term || new Term::ReadLine 'Repl';

    # completion to do ?...!
    local our $attribs= $term->Attribs;
    local $attribs->{attempted_completion_function}= sub {
	my ($text, $line, $start, $end) = @_;
	$attribs->{completion_append_character}=" ";#reset to the default before deciding upon it.
	#local our @matches=  geht nid gell?. oder doch?. heh. intertging h perl. so .
	#my @matches=
	#oder eben warum nid einfach..:
	my $matches=[];
	if (@$matches) {
	    $attribs->{completion_word}= $matches;# sort is not necessary.
	    # return:
	    $term->completion_matches
	      ($text,
	       $attribs->{list_completion_function});
	} else {
	    $attribs->{completion_append_character}=" ";  ##hab oben doch eh ??
	    # return:
	    ()
	}
    };
    my $OUT = $term->OUT || *STDOUT;## * korrekt?
    my $STDOUT= $OUT; my $STDERR= $OUT;

    # history
    my $history=[];
    $term->clear_history; ##was were wenn nicht clearen??
    for (@$history) {
	chomp;
	$term->addhistory($_);
    }
    # do not add input to history automatically (allow me to do it myself):
    #$term->MinLine(undef);

    # hm do we really  need that much paper up ???:
    ##todo SIGINT handler??
    my $myreadline=sub {
      DO:{
	    my $line= eval {
		$term->readline($$self[Prompt]);
	    };
	    if ($@) {
		if (!ref($@) and
		    ($@ eq "SIGINT\n"
		     or $@=~ /^SIGINT\n\t\w/s # when use Chj::Backtrace is in use
		    )) {
		    print $STDOUT "\n";
		    redo DO;
		} else {
		    die $@
		}
	    }
	    return $line;
	}
    };

    while ( defined (my $input = &$myreadline) ) {
	chomp $input and warn "DID in fact remove newline?";
	my @cmds= split /;/, $input; ##todo care about quoting...
	for (@cmds) {
	    xsystem("xmms2 $_");
	}
    }
    #use Chj::Backtrace; use Chj::repl; repl;
}
run
#use Chj::ruse;

