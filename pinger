#!/usr/bin/perl -w

use strict;

$0=~ /([^\/]+)$/s or die "?";
my $myname=$1;
sub usage {
    if (@_) {
	print @_,"\n";
    }
    print "$myname address
  Continuously pings address and beeps or pops up a dialog if it can't reached.
  For use with bad network cabling so you know when you've lost connectivity.
";
    exit(@_ ? 1 : 0);
}


use Getopt::Long ':config'=> 'bundling';
use Fcntl;
use Time::HiRes 'usleep';
use Chj::xperlfunc;

our $verbose;
our $opt_popup;
our $opt_callback; #our $opt_command; #our $opt_callback;
our $opt_retryperiod;
usage unless GetOptions (
			 'verbose|v'=>\$verbose,
			 'popup|dialog|p'=>\$opt_popup,
			 'callback|cmd=s'=> \$opt_callback,
			 'retryperiod=i'=> \$opt_retryperiod,
			);

usage unless @ARGV==1;
my $address= shift;
usage if $address=~ /^-/;
usage "don't give both --popup and --callback options" if $opt_callback && $opt_popup;


our ($trouble_on_cb,
     $trouble_off_cb,
     $expecttime,
     $maybe_retrytime,
    );

if ($opt_popup) {
    $expecttime= 2; # (at first I thought it would have to be longer but it was just that I didn't kill, just wait, upon backingup event, and only did survive that block by chance with the signal, but alas, problem.)
    $maybe_retrytime= defined($opt_retryperiod) ? $opt_retryperiod : undef;# well it wouldn't make sense here? except to re-rise the window.
    my $childpid;
    my $waitpid= sub {
	waitpid $childpid,0;
	$childpid= undef;
    };	
    my $maybe_killchild= sub {
	if ($childpid) {
	    kill 9, $childpid;
	    &$waitpid;
	}
    };
    $trouble_on_cb= sub {
	&$maybe_killchild;
	if ($childpid= xfork) {
	    # nothing
	} else {
	    xexec "xmessage", localtime()." $myname: network down event"
	}
    };
    $trouble_off_cb= sub {
	&$maybe_killchild;
    };
} elsif ($opt_callback) {
    $expecttime= 6; # give it more time // do not be too sensitive.
    $maybe_retrytime= defined($opt_retryperiod) ? $opt_retryperiod : 10;
    $trouble_on_cb= sub {
	xsystem $opt_callback;
    };
    $trouble_off_cb= sub {
	# noop
    };
} else {
    $expecttime= 2;
    $maybe_retrytime= defined($opt_retryperiod) ? $opt_retryperiod : 10; # beep every 10 seconds, that was what it did in the old version
    $trouble_on_cb= sub {
	xxsystem "/root/bin/beeponserver";
	usleep 150000;
	xxsystem "/root/bin/beeponserver";
    };
    $trouble_off_cb= sub {
	xxsystem "/root/bin/beeponserver";
    };
}



pipe READ,WRITE
  or die $!;

my $pid=xfork;

if ($pid) {
    #father
    close WRITE;
    $SIG{ALRM}= sub {
        die "ALRM\n";
    };
    my $lastbeep=undef;
    while(1) {
        eval {
            alarm $expecttime;
            while (<READ>) {
		# success, got ping back
                if ($lastbeep) {
		    # been in trouble, not any more
		    alarm 0;
                    $lastbeep=undef;
                    print localtime()."\tWEITER\n";
                    &$trouble_off_cb;
                }
                alarm $expecttime;
                print "$_" if $verbose;
            }
        };
        die unless $@ eq "ALRM\n";
        my $time=time;
        if (not(defined($lastbeep))
	    or
	    ($maybe_retrytime and $time-$lastbeep > $maybe_retrytime)) {
            $lastbeep=$time;
            print localtime($time)."\tUNTERBRUCH\n";
	    alarm 0;
	    &$trouble_on_cb;
        }
    }
}
else {
    close READ;
    open STDOUT,">&WRITE";
    exec "ping",$address;
    die
}
