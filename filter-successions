#!/usr/bin/perl -w

# Tue Feb 17 13:02:56 EST 2009
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname

  reads lines on stdin, and folds following ones (using the perl ++ operator) into one with '..' inbetween.

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   ) or exit 1;
usage if @ARGV;

my $begin;

my $oldline;

while (<STDIN>) {
    chomp;
    if (defined $begin) {
	my $newline= $oldline; $newline++;
	if ($newline eq $_) {
	    # that's it
	    #ehr well not yet, need this  mutation:
	    $oldline=$newline;
	} else {
	    #print "$begin..$_\n" ah that's wrong. grr.
	    print "$begin..$oldline\n"
	      or die $!;
	    #^ hm still wrong, should check for eq right?.
	    #undef $begin; worng=!.
	    $begin= $_; $oldline=$_;
	}
    } else {
	$begin= $_; #wrong
	#$begin=$;#ehr above it was wrong.
	$oldline= $_;
    }
}

if (defined $begin) {
    if ($begin eq $oldline) {
	die "$myname: only got one input item\n";
	#^ correct?
	#and  or   what/how to handle this case above! ?.
    } else {
	#copy.
	print "$begin..$oldline\n"
	  or die $!;
	#/copy.
    }
} else {
    # could be either been no input at all. or just given a range because of .. #at this point i 'fixed' the $line into $oldline and $newline stuff above   and wel.
}

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
