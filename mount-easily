#!/usr/bin/perl -w

# Mon Apr 27 15:33:14 EDT 2009
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname device

  Automatically turns the device path into a mount path and mounts the
  device on that path. Errors out when something is mounted on the
  choosen path already.

  Automatically uses -o loop if the 'device' path is a regular file.

  Options:
  -c|--create-dir  create mount path [if it doesn't exist already]
  --private create mount path as \$dest_path/mnt/ subdirectory and
            create \$dest_path with 0700 permissions. If mount path
            already exists, require it to have a mnt/ subdirectory
            (and use that, which will be done anyway, but with
            --private it fails if that directory doesn't exist) [and
            check the parent dir for 0700 perms? well no for now]
  --ro|--readonly
  [--noatime wll use as default anyway ok?]

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

use Getopt::Long;
our $verbose=0;
#our @mountoptions=(); ehr no,
our $mountoptions= { noatime => 1 };
our $opt_createdir;
our $opt_private;
GetOptions("verbose"=> \$verbose,
	   "help"=> sub{usage},
	   "ro|readonly"=> sub {
	       $$mountoptions{ro}=1;
	   },
	   "noatime"=> sub {
	       $$mountoptions{noatime}=1;
	   },
	   "c|create-dir"=> \$opt_createdir,
	   "private"=> \$opt_private,
	   ) or exit 1;
usage unless @ARGV==1;

use Chj::Unix::Mount 'mounted','mount';
use Chj::xperlfunc qw(xmkdir basename dirname xstat);
sub mydie { #forever
    die "$myname: @_\n";#hm or join  ?.  a forever-*question*
}

use Chj::xrealpath;
use Chj::xopendir;
#sub dev_to_maybe_
sub maybe_uuid_from_dev {
    my ($devpath)=@_;
    my $search= xrealpath $devpath;
    my $base= "/dev/disk/by-uuid";
    my $d= xopendir $base;
    # local chdir wl. wt gmb provides. eben manuell dieses machen hier.
    while (defined (my$item=$d->xnread)) {
	my $found= xrealpath "$base/$item";
	if ($found eq $search) {
	    return $item
	}
    }
    $d->xclose;
    undef
}

use Chj::IO::Command;

sub try_file {
    # do not throw exception on error, but return an error (not false in perl5..)
    # well why not the tuple case. boolean   there  still.
    # hm.   (vs multiple cont vs x..)
    my ($devpath)=@_;
    # could also be file. no problem.
    my $in= Chj::IO::Command->new_sender
      ("file","--brief","--special-files",$devpath);
    my $cnt= $in->xcontent;
    my $res= $in->xfinish;
    ($res==0,$cnt)
}

sub maybe_luks { # not just is_luks. ok?. I mean: give luks details if luks.
    my ($devpath)=@_;
    my ($ok,$cnt)= try_file $devpath;
    if ($ok) {
	if ($cnt=~ /^LUKS encrypted/) {
	    $cnt
	} else {
	    undef
	}
    } else {
	die "error checking '$devpath': $cnt";
    }
}

use Chj::xperlfunc;

sub mount_easily {
    my ($device_path)=@_;
    #my $dir= dirname $device_path;###  how to use it ?. notatalll ?

    # check whether we need -o loop: (safe enough?hopeso)
    {
	my $s= xstat $device_path;
	if ($s->is_file) {#hm is_regular ?
	    $$mountoptions{loop}=1
	} elsif ($s->is_blockdevice) {
	    delete $$mountoptions{loop} # =0 is not enough if I'm taking keys..
	} else {
	    die "hm?, file '$device_path' is neither block device nor regular file"
	}
    }

    my $maybe_uuid= maybe_uuid_from_dev $device_path;
    my $id= defined($maybe_uuid)? $maybe_uuid : basename $device_path;

    if (my $luks= maybe_luks $device_path) {
	print $luks;
	my $devicemapper_path= "/dev/mapper/$id"; #ok diese id hier zu verwenden? well schon oder? oder sollte ich device name nehmen ?. well eben selber wählen. manuell auch ein name.  - aber ja wenn manuell verwend ich den namen beim mount point wieder.
	my $open= sub {
	    xxsystem "cryptsetup", "luksOpen", $device_path, $id;
	    ##hm what with failed pw's? retry?.
	};
	if (-e $devicemapper_path) {
	    # check whether it's still working
	    my ($ok,$cnt)= try_file $devicemapper_path; # yeh it's a bit a misuse of that tool right?...
	    if ($ok) {
		#if ($cnt=~ )
		#no need to check.
		# already set up
	    } else {
		if ($cnt=~ m|Input/output error|i) {
		    xxsystem "cryptsetup", "luksClose", $devicemapper_path;
		    &$open
		} else {
		    die "unexpected error checking '$devicemapper_path': $cnt";#well doppelmoppel path in err msg.
		}
	    }
	} else {
	    &$open
	}
	# here comes the mutation:
	$device_path= $devicemapper_path;
	# hm and now get the id of the decrypted volume ?. or actually
	# hide that??. hide / ignore it for now and we get the "same
	# id for mapper and for mount point" behaviour.
	# Question: maybe I even *want* that behaviour of using the id
	# of the (outmost) *container*?: I could mount a copy twice
	# you "knw!"
    }

    my $dest_path=  "/mnt/".$id;
    my $mount_on= sub ( $ ) {
	my ($dest_path)=@_;
	my $options= join(",", keys %$mountoptions);
	mount( (length $options ? ("-o",$options) : ()),
	       $device_path,
	       $dest_path);
    };
    my $private_dest_path= $dest_path."/mnt";
    if (-e $dest_path) {
	if (mounted $dest_path) {
	    mydie "there is already something mounted on '$dest_path'";
	} else {
	    if (-e $private_dest_path) {
		if (mounted $private_dest_path) {
		    mydie "there is already something mounted on '$private_dest_path'";
		} else {
		    &$mount_on( $private_dest_path);
		}
	    } else {
		if ($opt_private) {
		    mydie "--private option given but private '$private_dest_path' mount point does not exist (while '$dest_path' exists)"
		} else {
		    &$mount_on( $dest_path);
		}
	    }
	}
    } else {
	if ($opt_createdir) {
	    #or ask for it  ? wl or no, just rerun program then.with the option.
	    if ($opt_private) {
		xmkdir $dest_path, 0700;
		xmkdir $private_dest_path, 0700; #(perms for consistency only, not really relevant)
		&$mount_on( $private_dest_path);
	    } else {
		xmkdir $dest_path;
		&$mount_on( $dest_path);
	    }
	} else {
	    mydie "target dir '$dest_path' does not exist and --create-dir option not given"
	}
    }
}

mount_easily $_ for @ARGV;

#use Chj::ruse;
#use Chj::Backtrace; use Chj::repl; repl;
