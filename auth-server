#!/usr/bin/perl -w

# Don Aug  2 20:26:53 CEST 2007
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname socketpath statedir

  Opens the unix socket at the given path, listens for connections,
  writes into statedir the last attempt(s) for a particular user
  to prevent dictionary attacks, returns whether the password is
  valid.

  Only checks /etc/{passwd,shadow}.

  Prevents authentification queries for users resolving to the uid 0.

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

my @args;
my $DEBUG=0;
for (my $i=0; $i<=$#ARGV; $i++) {
    local $_=$ARGV[$i];
    if (/^--?h(elp)?$/) {
    	usage
    } elsif ($_ eq '--') {
    	push @args, @ARGV[$i+1..$#ARGV];
    	last;
    } elsif (/^--?d(ebug)?$/) {
	$DEBUG=1;
#     } elsif (/^--?X(?:XXX(?:=(.*))?)?$/) {
#         if (defined $1) {
#             $XXX=$1
#         } else {
#             $XXX=$ARGV[++$i] or usage "missing argument for '$_' option";
#         }
    } elsif (/^-./) {
    	usage("Unknown option '$_'\n");
    } else {
    	push @args, $_
    }
}
usage unless @args==2;

our ($socketpath,$statedir)=@args;

use Chj::Unix::Authenticate;
use POSIX 'EINTR';

our $auth= Chj::Unix::Authenticate->new(service=>"login");#(the sole service supportded by that module)


use IO::Socket::UNIX;

$SIG{PIPE}= sub { }; #!! auch im server naturli.

unlink $socketpath;
our $sock= IO::Socket::UNIX->new(
				 Type=> SOCK_STREAM,
				 Local=> $socketpath,
				 Listen=> 10, # not a boolean, but a queue length right?.
				 #ReuseAddr=> 1, huh doesn't help. thus unlink above.
				)
  or die $!;#!

our $childcount=0;

#$sock->bind or die $!; not needed  andwrong as such.

sub parse_singlequote_from_buf {
    my ($bufrf,$startpos)=@_;
    pos($$bufrf)=$startpos;
    #while ($$bufrf=~ m/(?!<\\)\'/sg) {  und PROMPT veergessen anzupasen.  Langs welche costly fn calls haben sucken.
    while ($$bufrf=~ m/(?<!\\)\'/sg) {
	my $pos0=pos ($$bufrf);
	while ($$bufrf=~ m/(?<!\\)\'/sg) {
	    my $pos1= pos ($$bufrf);
	    my $substr= substr ($$bufrf,$pos0,$pos1-$pos0-1);
	    $substr=~ s/\\(.)/$1/sg;
	    #return wantarray ? ($substr,$pos1) : $substr
	    return ($substr,$pos1)
	}
	die "missing end of string";
    }
    return
}


sub handle_conn {
    local our ($conn)=@_;
    #$conn->timeout(1); #ok?  grrr warum nützt das nichts?????. weder auf senden noch lesen!!
    #use Chj::repl;repl;

    my $buf;
    defined ($conn->recv($buf,1024)) or die "recv: $!"; # the defined is relevant! (man perlfunc)
    # assume that the whole message has fit into the buffer.
    $buf=~ s/^check // or die "invalid query, does not start with 'check '";
    my $error=sub {
	$conn->send(join " ",@_)
	  or die "error send (@_): $!";
    };
    if (my ($user,$pos)= parse_singlequote_from_buf(\$buf,0)) {
	if (my ($pass,$pos)= parse_singlequote_from_buf (\$buf,$pos)) {
	    if (parse_singlequote_from_buf (\$buf,$pos)) {
		&$error ("superfluous string");
	    } else {
		my $reply= do {
		    if (my $u= $auth->authenticate ($user,$pass)) {
			if ($u->uid != 0) {
			    "1"
			} else {
			    "0"
			}
		    } else {
			"0"
		    }
		};
		$conn->send($reply)
		  or die "send: $!";
	    }
	} else {
	    &$error ("missing pass");
	}
    } else {
	&$error ("missing user and pass");
    }
}

our $do_alarm=0;
#$SIG{ALRM}= sub { die "ALRM\n" if $do_alarm };
$SIG{ALRM}= sub {
    if ($do_alarm) {
	warn "sending aralm";
	die "ALRM\n"
    }
};

loop: {
    while (local our $conn= $sock->accept) {
	eval {
	    {
		local $do_alarm=1;# is this better against races? (than switching alarm off or removing signal handler)
		alarm 3;
		handle_conn($conn);
		# have to take close also under timeout control,right?
		#$conn->close
		#  or die "close: $!";
		#ACH: aber muss auch bei exn close machen.   am ende isch es einfach broken. xnzeu
	    }
	};
	if (ref $@ or $@) {
	    warn "got exception: $@";
	}
	eval {
	    {
		alarm 3;
		local $do_alarm=1;
		$conn->close
		  or die "close: $!";
	    }
	};
	if (ref $@ or $@) {
	    warn "got exception in closing stage: $@";
	}
    }
    #warn "no more connections? or what is broken?"; tritt wirklich auf: dann wenn client sleep 30000 vor seinem recv hat.  komisch aber dass hier kein exception vermelden passiert.
    # ah: weil  zwar kein die aber eben  unterbruch von betriebssys call. mensch. so was doofes.
    #warn "got here: $!";
    # perl tut also NICHT take care of hier.
    if ($! == EINTR) {
	warn "accept: got EINTR";
	redo loop;
    } else {
	die "accept: $!"
    }
}

