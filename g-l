#!/usr/bin/perl -w

# Sam Aug  4 09:08:25 CEST 2007
(my $email='XXX%YYY,ch')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname ..

  git list added/modified/deleted files. (obviously the latter only if
  they are still there, ehr)

  Like cg-status | grep '^[ADM]' | cut -c3- |myxargs_* l | cut ...off until date

  (Christian Jaeger <$email>)
";
exit (@_ ? 1 : 0);
}

my @args;
my $DEBUG=0;
for (my $i=0; $i<=$#ARGV; $i++) {
    local $_=$ARGV[$i];
    if (/^--?h(elp)?$/) {
    	usage
    } elsif ($_ eq '--') {
    	push @args, @ARGV[$i+1..$#ARGV];
    	last;
    } elsif (/^--?d(ebug)?$/) {
	$DEBUG=1;
#     } elsif (/^--?X(?:XXX(?:=(.*))?)?$/) {
#         if (defined $1) {
#             $XXX=$1
#         } else {
#             $XXX=$ARGV[++$i] or usage "missing argument for '$_' option";
#         }
    } elsif (/^-./) {
    	usage("Unknown option '$_'\n");
    } else {
    	push @args, $_
    }
}
usage if @args;

use Chj::IO::Command;
use Chj::Unix::exitcode;

{my $buf=""; sub BUFSIZ () { 4096 }
 my $got_eof;#from fh
 my $are_in_eof;
sub XReadline ( $ ) {
    my ($fh)=@_;
    return if $are_in_eof;
    # wo bringe ich puffer unter aber ? himmel schritt scrhtot.rott.
    #hack: global buf above
    if ($buf=~ s/^(.*?\n)//s) {
	warn "returning part of previously read buffer: '$1'";
	return $1
    } else {
	warn "HELLO?";
	if ($got_eof) {
	    warn "nothing more left in buffer and we got eof alrady, so return rest of buffer and end it";
	    $are_in_eof=1;
	    return $buf
	} else {
	    warn "get new data..";
	    use Chj::xperlfunc;
	    my $_buf;
	    my $n= xsysread ($fh,$_buf,BUFSIZ);
	    if ($n==0) {
		warn "got real eof";
		$got_eof= 1
	    } else {
		warn "got new data, adding to buf";
		$buf.=$_buf;
	    }
	    @_=($fh);
	    goto \&XReadline;
	}
    }
}
}

sub files {
    my $g= Chj::IO::Command->new_sender("git-status");

    my %files;
    #while (<$g>) {
    #while (defined ($_ = $g->xreadline)) {
    while (defined ($_ = XReadline ($g))) {
	last if /^# Untracked files/;
	chomp;
	if (/^#\s+(modified|deleted|added|new file):\s+(.*)/) { # hm it seems 'added' isn't used
	    my ($what,$path)=($1,$2);
	    $files{$path}=$what;
	}
    }
    #use Time::HiRes 'sleep';
    #sleep 0.1; #huh g*d help me why is this needed on elvis-5? or git-status exits with code 141 most of the time. with git version 1.5.2.2
    my $rv= $g->xfinish;
    $rv==0 or $rv==1<<8  # (1 is when nothing's ready to commit)
      or die "git-status exited with an error (".Chj::Unix::exitcode($rv).")";
    \%files
}

my $modmap= {
	     modified=>"M",
	     deleted=> "D",
	     'new file'=> "A"
	    };
sub main {
    my $files= files;
    return unless keys %$files;
    my $l= Chj::IO::Command->new_sender ("l", keys %$files);
    while (<$l>) {
	chomp;
	# chop off '-rw-r--r-- 1 clamavbuild clamavbuild 4119'
	s/^[-l][-rwSstx]{9} +\d+ +\S+ +\S+ +\d+ +// or die "line dos not match: '$_'";
	/^\S+ +\S+ +(.*)/ or die "line (date part) does not match: '$_'";
	my $file=$1;
	my $kind= $$files{$file} or die "bug";
	{
	    my $kind= $$modmap{$kind} or die "bug '$kind'";#need the my. or the die would print the new, undef, value. tja.
	    print "$kind ",$_,"\n" or die "printing to stdout: $!";
	}
    }
}

main;
