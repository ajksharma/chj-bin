#!/usr/bin/perl -w

use strict;
use Chj::backtick qw/xbacktick/;
use Chj::xperlfunc ':all';
use Chj::xrealpath;

# a manual symlink resolver, but only the last path segment (unlike
# xrealpath or chase):

use Chj::singlequote;

sub xsymlinkresolve ( $ ); # even if I'm using parens below, this is necessary. ~gr.
sub xsymlinkresolve ( $ ) {
    my ($path)=@_;
    my $s= xlstat $path;
    if ($s->is_link) {
	my $l= xreadlink $path;
	if ($l=~ m|^/|) {
	    xsymlinkresolve ($l)
	} else {
	    # need path resolving, hum. and not based on path actually.
	    # well the simple case is easy:
	    if (not $l=~ m|/|) {
		xsymlinkresolve( dirname ($path)."/".$l )
	    } else {
		# yep now really needs somehow turning to xrealpath right?
		# doh?.
		xrealpath $path
		  #well todo, could manually checkandresolve as long as it doesn't hm. it needs an xrealpath which only resolves up to those points right. hm
	    }
	}
    } else {
	$path=~ s|//+|/|sg;
	$path=~ m{(?:^|/)\.\.(?:\z|/)}
	  and die "path contains '..' segments: ".singlequote ($path);
	$path
    }
}

sub usage {
    print "usage: dpkgS commandname|file/path
";
    exit;
}

usage unless @ARGV;

my $errors=0;

for my $command_or_path (@ARGV) {
    if ($command_or_path=~ /^-/) {
	usage
    } else {
	local $/;
	my $path= do {
	    if ($command_or_path=~ /\//) {
		$command_or_path
	    } else {
		# it could be a command
		my $path= xbacktick("which",$command_or_path);
		if ($? == 0) {
		    chop $path;
		    $path
		} else {
		    $command_or_path
		}
	    }
	};
	my $symlinkresolved_path= xsymlinkresolve $path;
	if (not 0== xsystem "dpkg", "-S", $symlinkresolved_path) {
	    $errors++;
	}
    }
}

exit ($errors? 1 : 0);
