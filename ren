#!/usr/bin/perl -w

# Fre Nov 19 21:59:21 MET 2004
(my $email='christian%jaeger,mine,nu')=~ tr/%,/@./;

use strict;

$0=~ /(.*?)([^\/]+)\z/s or die "?";
my ($mydir, $myname)=($1,$2);
sub usage {
    print STDERR map{"$_\n"} @_ if @_;
    print "$myname item(s)

  this is rene, your file/folder renaming tool. it has lost it's trailing e
  becaus it was deamed to loong.
  interactively asks for the new name of each of them.

  (Christian Jaeger <$email>)
";
exit @_ ? 1 : 0;
}

use Getopt::Long;
our $DEBUG=0;
our $opt_print_only;
GetOptions("d|debug"=> \$DEBUG,
	   "help"=> sub{usage},
	   "print-only"=> \$opt_print_only,
	  ) or exit 1;
usage unless @ARGV;

use Chj::xperlfunc qw(xrename xlinkunlink Xlstat);
use Term::ReadLine;
my $rl= Term::ReadLine->new("rename");

$rl->ornaments(0);

#use Chj::xtmpfile;
use Chj::xsysopen 'xsysopen_excl';
#our $assumed_minimal_length=
our $seed_length=20; # bytes of binary input
use Chj::Random::Formatted 'random_passwd_string';
use POSIX 'ENAMETOOLONG';
sub _maxfilenamelen {
    @_==2 or die "args";
    my ($in_folder, $upto_n)=@_;
    #my $f= xtmpfile $in_folder;
    #my $spath= $f->path;
    # use link or rename? problem with link on sshfs, sigh. and rename
    # saves unlink.  but then, it is not safe. as long as it's under
    # some considerable length.
    # so, do not use xtmpfile but instead?:
    my $sname= random_passwd_string $seed_length;
    #hm, guarantee there are no / in it:
    $sname=~ s|/||g; length ($sname) > 25 or die "shouldn't happen";
    #my $spath= "$in_folder/$sname"; wrong, $in_folder can be "" which actually means "." in this case, not the filesystem root.
    my $spath= length($in_folder) ? "$in_folder/$sname" : $sname;
    my $f= xsysopen_excl $spath;
    $f->xclose;
    #my $morerandom= random_passwd_string $seed_length; # wl ? really stupid right.
    my $len= length ($sname);
  LP: {
	my $path= $spath . "a";
	$!= 0; # !!!
	if (rename $spath, $path) {
	    $spath=$path;
	    $len++;
	    if ($len <= $upto_n) {
		redo LP;
	    } else {
		die "overran given limit $upto_n while testing maxfilenamelen in '$in_folder'"
	    }
	} else {
	    if ($! == ENAMETOOLONG) {
		unlink $spath
		  or die "??? could not unlink '$spath': $!";
		$len
	    } else {
		die "error while testing maxfilenamelen in '$in_folder': rename '$spath','$path': $!"
	    }
	}
    }
}

my %cached_maxfilenamelen;
sub cached_maxfilenamelen {
    @_==2 or die "args";
    my ($in_folder, $upto_n)=@_;
    # only consider first argument, since if it succeeded, then the
    # second argument becomes moot
    #$cached_maxfilenamelen{$in_folder}||= _maxfilenamelen ($in_folder, $upto_n)
    if (defined (my $v= $cached_maxfilenamelen{$in_folder})) {
	$v
    } else {
	$v = _maxfilenamelen ($in_folder, $upto_n);
	$cached_maxfilenamelen{$in_folder}= $v;
	$v
    }
}

sub ren {
    my ($path)=@_;

    lstat $path or die "'$path': $!";
    my $path_is_d= -d _;

    $path=~ s|/+\z||s;
    #^ + ist wichtig!
    my ($folder,$filename)= $path=~ m|(.*?)([^/]+)\z|s
      or die "given empty path";
    #print "fol=$folder, fn=$filename\n";
    #(# well, . und .. wär noch eventualkritisch.  ?)

    my $newname= $filename;
  REDO: {
	if (defined($newname= $rl->readline("rename: ",$newname))){
	    if (length($newname)) {
		if ($newname ne $filename) {
		    my $newpath= "$folder$newname";
		    #print "newpath='$newpath'\n";
		    if (lstat $newpath) {
			die "target exists"; # ask user for forcing instead?
			if(!1){
			    return
			}
		    }
		    eval {
			if ($opt_print_only) {
			    print $newpath."\n";
			} else {
			    if ($path_is_d) {
				xrename $path,$newpath;
			    } else {
				# be unrisky to race conds
				eval {
				    xlinkunlink $path,$newpath;
				    1
				} or do {
				    my $e=$@;
				    if ($e=~
					m/can't link to target: (?:Function not implemented|Operation not permitted)/
				       ) {
					# sshfs.
					die "target already exists (maybe as symlink): '$newpath'"
					  if Xlstat( $newpath);
					#^ah checked anyway already, "unfini" above. whatever.
					xrename $path,$newpath;
				    } else {
					die $e
				    }
				};
			    }
			}
		    };
		    my $e=$@;
		    if (ref $e or $e) {
			if ($e=~ /too long/) {
			    my $actual= length $newname;
			    my $allowed= cached_maxfilenamelen $folder, $actual;
			    print "The new name is ".($actual - $allowed)." character(s) too long.\n";#ordie
			    redo REDO;
			} else {
			    die $e
			}
		    }
		}
	    }
	}
    }
}

sub _ren {
    eval {
	&ren
    };
    if ($@) {
	my $e=$@;
	$e=~ s/ at \S.* line \d+.{1,2}$//s;#warum geht $ aber nicht \z ah logo.
	chomp $e;
	print STDERR "$e\n";
    }
}

_ren $_ for @ARGV;

